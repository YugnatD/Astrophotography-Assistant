C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MASTER_TELESCOPE_V3
OBJECT MODULE PLACED IN .\Objects\Master_Telescope V3.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Master_Telescope V3.c OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(
                    -.\Listings\Master_Telescope V3.lst) TABS(3) OBJECT(.\Objects\Master_Telescope V3.obj)

line level    source

   1          /*===========================================================================*=
   2             Master_Telescope - Tanguy Dietrich
   3            =============================================================================
   4             Descriptif: 
   5             Gestion de moteur d'une monture NEQ5.
   6             Le moteur R.A a une vitesse constante correspondant a la vitesse sideral.
   7             Le moteur DEC est activer lorsque la pin p2.2 ou P2.3(ST4) sont a 0
   8             Le tout est commander avec un port ST4
   9          =*===========================================================================*/
  10          
  11          #include <reg51f380.h>     // registres 51f38C
  12          #include "Vitesse_Moteur.h"
  13          #include "Delay48M.h"
  14          #include "SmBus0.h"
  15          #include "string.h"
  16          
  17          #define CONFIG_PAGE 0x0F
  18          #define LEGACY_PAGE 0x00
  19          #define BAUD_UART0 247 //247=57600
  20          
  21          //PCB
  22          sbit STEP_RA = P1^3;
  23          sbit DIR_RA = P1^2;
  24          sbit NSLEEP_RA = P1^0;
  25          sbit NFAULT_RA = P1^1;
  26          
  27          sbit STEP_DEC = P1^7;
  28          sbit DIR_DEC = P1^6;
  29          sbit NSLEEP_DEC = P1^4;
  30          sbit NFAULT_DEC = P1^5;
  31          
  32          sbit ST4_RA_NEG = P2^0;
  33          sbit ST4_RA_POS = P2^1;
  34          sbit ST4_DEC_NEG = P2^2;
  35          sbit ST4_DEC_POS = P2^3;
  36          
  37          sbit SDA = P0^0;
  38          sbit SCL = P0^1;
  39          
  40          
  41          // ==== FONCTIONS PROTOTYPES===================================================
  42          void ClockInit ();         // init. clock syst�me
  43          void PortInit ();          // init. config des ports
  44          void TimerInit();
  45          void Init_int();
  46          void SMBus_Init (void);
  47          void Timer3_Init (void);
  48          void Timer2_Init (void);
  49          void SMB_Write (void);
  50          void SMB_Read (void);
  51          void UART_Init();
  52          void decodeUartRaspberryPi();
  53          void setMotorRA(unsigned char vitesse,bit direction);
  54          void setMotorDEC(unsigned char vitesse,bit direction);
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 2   

  55          void stopMotorDec();
  56          void configMCP23008(unsigned char input);
  57          unsigned char read_i2c_port();
  58          void reset_i2c();
  59          // ==== MAIN ==================================================================
  60          
  61          //SMBus0
  62          unsigned char gSMBNumBytesToWR = 2; // Number of bytes to write
  63                                              // Master -> Slave
  64          unsigned char gSMBNumBytesToRD = 3; // Number of bytes to read
  65                                              // Master <- Slave
  66          
  67          // Global holder for SMBus data
  68          // All receive data is written here
  69          unsigned char gSMBDataIN[NUM_BYTES_MAX_RD];
  70          
  71          // Global holder for SMBus data.
  72          // All transmit data is read from here
  73          unsigned char gSMBDataOUT[NUM_BYTES_MAX_WR];
  74          
  75          unsigned char gTarget;                  // gTarget SMBus slave address
  76          
  77          bit SMB_BUSY;                          // Software flag to indicate when the
  78                                                 // SMB_Read() or SMB_Write() functions
  79                                                 // have claimed the SMBus
  80          
  81          bit SMB_RW;                            // Software flag to indicate the
  82                                                 // direction of the current transfer
  83          
  84          unsigned long NUM_ERRORS;              // Counter for the number of errors.
  85          
  86          
  87          
  88          
  89          //Gestion Moteur
  90          unsigned char gVitesseRAH=VITESSE_RA_SIDERAL_HIGH;
  91          unsigned char gVitesseRAL=VITESSE_RA_SIDERAL_LOW;
  92          unsigned int gVitesseDEC=VITESSE_DEC_MAX;
  93          unsigned char gVitesseDeplacement=VITESSE_MAX;
  94          
  95          //Uart
  96          xdata unsigned char gUart0Tx[10]="";
  97          xdata unsigned char gUart0Rx[10];
  98          unsigned char gUart0NbrByteTx=0;
  99          unsigned char gUart0NbrByteRx=0;
 100          bit gUart0FlagReceive;
 101          
 102          xdata unsigned char gUart1Tx[10]="";
 103          xdata unsigned char gUart1Rx[10];
 104          unsigned char gUart1NbrByteTx=0;
 105          unsigned char gUart1NbrByteRx=0;
 106          bit gUart1FlagReceive;
 107          bit gDirRa=0;
 108          bit gDirDec=0;
 109          unsigned char gAstrSuivi=0;
 110          bit gFlagMovingRA=0;
 111          
 112          void main () 
 113          {
 114   1         unsigned char portExtender;
 115   1         unsigned char memoAstreSuivi=0;
 116   1         bit waitEndMove=0;
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 3   

 117   1         PCA0MD &= ~0x40;     // WDTE = 0 (disable watchdog timer)
 118   1         ClockInit ();        // init. clock syst�me
 119   1         PortInit ();         // init. config des ports
 120   1         SDA=1;
 121   1         reset_i2c();
 122   1         Init_int();
 123   1         Timer3_Init();                      // Configure Timer3 for use with SMBus
 124   1                                             // low timeout detect
 125   1         Timer2_Init();
 126   1      
 127   1         SMBus_Init ();                      // Configure and enable SMBus
 128   1         UART_Init();
 129   1         TimerInit();
 130   1         EA=1;//Autorise toutes les interruption
 131   1         EIE1      |= 0x81;
 132   1          EIE2      |= 0x12;
 133   1          IE        |= 0x97;
 134   1         TR0 = 1;//lance le timer 0
 135   1         TR1=1;
 136   1         NSLEEP_RA=1;//Active le chip drv8825
 137   1         NSLEEP_DEC=0;
 138   1         DIR_RA=0;
 139   1         DIR_DEC=0;
 140   1         
 141   1         SDA=1;
 142   1         Delay_1ms (20);
 143   1         configMCP23008(0xFF);
 144   1         portExtender=read_i2c_port();
 145   1         gAstrSuivi=(portExtender>>4);
 146   1         //memoAstreSuivi=gAstrSuivi;
 147   1         while (1)
 148   1         {
 149   2            memoAstreSuivi=gAstrSuivi;
 150   2            gVitesseDeplacement=(P2>>4)+VITESSE_X05;
 151   2            portExtender=read_i2c_port();
 152   2            gAstrSuivi=(portExtender>>4);
 153   2            gDirRa=(portExtender&0x04)>>2;
 154   2            gDirDec=(portExtender&0x08)>>3;
 155   2            
 156   2            if((memoAstreSuivi!=gAstrSuivi)||(waitEndMove==1))
 157   2            {
 158   3               waitEndMove=1;
 159   3               if(gFlagMovingRA==0)
 160   3               {
 161   4                  setMotorRA(gAstrSuivi,gDirRa);
 162   4                  waitEndMove=0;
 163   4               }
 164   3            }
 165   2            
 166   2            if((NFAULT_RA==0)&&(NSLEEP_RA==1))//probleme sur le DRV8825 de l'axe R.A
 167   2            {
 168   3               NSLEEP_RA=0;
 169   3               Delay_1ms (10);
 170   3               NSLEEP_RA=1;
 171   3               Delay_1ms (10);//1.7ms necessaire au rallumage
 172   3            }
 173   2            
 174   2            if((NFAULT_DEC==0)&&(NSLEEP_DEC==1))//probleme sur le DRV8825 de l'axe DEC
 175   2            {
 176   3               NSLEEP_DEC=0;//Eteint
 177   3               Delay_1ms (10);
 178   3               NSLEEP_DEC=1;//Allume
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 4   

 179   3               Delay_1ms (10);
 180   3            }
 181   2            
 182   2            if(gUart0FlagReceive)
 183   2            {
 184   3               gUart0FlagReceive=0;
 185   3               while(gUart0NbrByteTx!=0);
 186   3               decodeUartRaspberryPi();
 187   3            }
 188   2            
 189   2            if(gUart1FlagReceive)
 190   2            {
 191   3               while(gUart0NbrByteTx!=0);
 192   3               gUart1FlagReceive=0;
 193   3               strcpy(gUart0Tx,gUart1Rx);
 194   3               TI0=1;
 195   3            }
 196   2            
 197   2         } // End while (1)
 198   1      } // main =====================================================================
 199          
 200          //INTERRUPTION
 201          /*---------------------------------------------------------------------------*-
 202          interruption0()
 203          -----------------------------------------------------------------------------
 204          Descriptif: Fonction d'interruption INT0 vecteur 0
 205                      Pin :P0.6 - Descendant
 206          Entree    : --
 207          Sortie    : --
 208          -*---------------------------------------------------------------------------*/
 209          void interruption_ST4_RA() interrupt 0
 210          {
 211   1         IT01CF=IT01CF^0x08;
 212   1         if((!ST4_RA_POS)&&(!ST4_RA_NEG))
 213   1         {
 214   2            setMotorRA(gAstrSuivi,gDirRa);
 215   2            gFlagMovingRA=0;
 216   2         }
 217   1         else if((ST4_RA_POS)&&(ST4_RA_NEG))
 218   1         {
 219   2            setMotorRA(gAstrSuivi,gDirRa);
 220   2            gFlagMovingRA=0;
 221   2         }
 222   1         else if((ST4_RA_POS)&&(!ST4_RA_NEG))
 223   1         {
 224   2            setMotorRA(gVitesseDeplacement,!gDirRa);
 225   2            gFlagMovingRA=1;
 226   2         }
 227   1         else if((!ST4_RA_POS)&&(ST4_RA_NEG))
 228   1         {
 229   2            setMotorRA(gVitesseDeplacement,gDirRa);
 230   2            gFlagMovingRA=1;
 231   2         }
 232   1      }
 233          /*---------------------------------------------------------------------------*-
 234          interruption1()
 235          -----------------------------------------------------------------------------
 236          Descriptif: Fonction d'interruption 1 vecteur 2
 237                      Pin :P0.7 - Descendant
 238          Entree    : --
 239          Sortie    : --
 240          -*---------------------------------------------------------------------------*/
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 5   

 241          void interruption_ST4_DEC() interrupt 2
 242          {
 243   1         IT01CF=IT01CF^0x80;
 244   1         if((!ST4_DEC_POS)&&(!ST4_DEC_NEG))//00
 245   1         {
 246   2            stopMotorDec();
 247   2         }
 248   1         else if((ST4_DEC_POS)&&(ST4_DEC_NEG))//11
 249   1         {
 250   2            stopMotorDec();
 251   2         }
 252   1         else if((ST4_DEC_POS)&&(!ST4_DEC_NEG))//10
 253   1         {
 254   2            setMotorDEC(gVitesseDeplacement,gDirDec);
 255   2         }
 256   1         else if((!ST4_DEC_POS)&&(ST4_DEC_NEG))//01
 257   1         {
 258   2            setMotorDEC(gVitesseDeplacement,!gDirDec);
 259   2         }
 260   1      }
 261          
 262          /*---------------------------------------------------------------------------*-
 263          timer0()
 264          -----------------------------------------------------------------------------
 265          Descriptif: Fonction d'interruption Timer0 vecteur 1
 266                    Temporisation de 51,94milli
 267                    Mode : 16bit
 268          Entree    : --
 269          Sortie    : --
 270          -*---------------------------------------------------------------------------*/
 271          void timer0() interrupt 1
 272          {
 273   1         TR0=0;
 274   1         TH0=gVitesseRAH ;//Charge la valeur dans le registre MSB du timer 0
 275   1         TL0=gVitesseRAL;//Charge la valeur dans le registre LSB du timer 0
 276   1         TR0=1;
 277   1         STEP_RA=!STEP_RA;
 278   1      }
 279          
 280          ///*---------------------------------------------------------------------------*-
 281          //timer1()
 282          //-----------------------------------------------------------------------------
 283          //Descriptif: Fonction d'interruption Timer1 vecteur 3
 284          //          Mode : 8 bit 9600baud
 285          //Entree    : --
 286          //Sortie    : --
 287          //-*---------------------------------------------------------------------------*/
 288          //void timer1() interrupt 3
 289          //{
 290          //   
 291          //}
 292          
 293          /*---------------------------------------------------------------------------*-
 294          timer4()
 295          -----------------------------------------------------------------------------
 296          Descriptif: Fonction d'interruption Timer4 vecteur 19
 297                    Mode : 16bit autoreload
 298          Entree    : --
 299          Sortie    : --
 300          -*---------------------------------------------------------------------------*/
 301          void timer4() interrupt 19
 302          {
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 6   

 303   1         static unsigned int cpt=0;
 304   1         SFRPAGE   = CONFIG_PAGE;
 305   1         TMR4CN &=~0xC0;//Clear pending flag
 306   1         SFRPAGE   = LEGACY_PAGE;
 307   1         cpt++;
 308   1         if(cpt>=gVitesseDEC)
 309   1         {
 310   2            STEP_DEC=!STEP_DEC;
 311   2            cpt=0;
 312   2         }
 313   1      }
 314          /*---------------------------------------------------------------------------*-
 315          uart0()
 316          -----------------------------------------------------------------------------
 317          Descriptif: Fonction d'interruption de l'uart0 vecteur 4
 318          Entree    : --
 319          Sortie    : --
 320          -*---------------------------------------------------------------------------*/
 321          void uart0() interrupt 4
 322          {
 323   1         if(TI0)
 324   1         {
 325   2            TI0=0;
 326   2            if(gUart0Tx[gUart0NbrByteTx]!=0)
 327   2            {
 328   3               SBUF0=gUart0Tx[gUart0NbrByteTx];
 329   3               gUart0NbrByteTx++;
 330   3            }
 331   2            else
 332   2            {
 333   3               gUart0NbrByteTx=0;
 334   3            }
 335   2         }
 336   1         
 337   1         if(RI0)
 338   1         {
 339   2            RI0=0;
 340   2            gUart0Rx[gUart0NbrByteRx]=SBUF0;
 341   2            if(gUart0Rx[gUart0NbrByteRx]=='#')
 342   2             {
 343   3                gUart0FlagReceive=1;
 344   3                gUart0Rx[gUart0NbrByteRx+1]=0;
 345   3                gUart0NbrByteRx=0;
 346   3             }
 347   2             else
 348   2             {
 349   3                gUart0NbrByteRx=(gUart0NbrByteRx+1)%20;
 350   3             }
 351   2         }
 352   1      }
 353          
 354          /*---------------------------------------------------------------------------*-
 355          uart1()
 356          -----------------------------------------------------------------------------
 357          Descriptif: Fonction d'interruption de l'uart1 vecteur 16
 358          Entree    : --
 359          Sortie    : --
 360          -*---------------------------------------------------------------------------*/
 361          void uart1() interrupt 16
 362          {
 363   1         if(SCON1&0x02)//TI1
 364   1         {
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 7   

 365   2            SCON1=SCON1&~0x02;
 366   2            if(gUart1Tx[gUart1NbrByteTx]!=0)
 367   2            {
 368   3               SBUF1=gUart1Tx[gUart1NbrByteTx];
 369   3               gUart1NbrByteTx++;
 370   3            }
 371   2            else
 372   2            {
 373   3               gUart1NbrByteTx=0;
 374   3            }
 375   2         }
 376   1         
 377   1         if(SCON1&0x01)//RI1
 378   1         {
 379   2            SCON1=SCON1&~0x01;
 380   2            gUart1Rx[gUart1NbrByteRx]=SBUF1;
 381   2            if(gUart1Rx[gUart1NbrByteRx]=='\n')
 382   2             {
 383   3                gUart1FlagReceive=1;
 384   3                gUart1Rx[gUart1NbrByteRx+1]=0;
 385   3                gUart1NbrByteRx=0;
 386   3             }
 387   2             else
 388   2             {
 389   3                gUart1NbrByteRx=(gUart1NbrByteRx+1)%20;
 390   3             }
 391   2         }
 392   1      }
 393          
 394          //FONCTION
 395          
 396          /*---------------------------------------------------------------------------*-
 397          reset_i2c()
 398          -----------------------------------------------------------------------------
 399          Descriptif: Verifie si le bus I2C est bloquer, et effectue un reset du bus
 400          Entree    : --
 401          Sortie    : --
 402          -*---------------------------------------------------------------------------*/
 403          void reset_i2c()
 404          {
 405   1         unsigned char i=0;
 406   1         if(!SDA)
 407   1         {
 408   2            //Desactive tout l'I2C
 409   2            P0SKIP    = 0x03;//skip les pin SCL SDA
 410   2            XBR0      = 0x01;//desactive l'I2C
 411   2            //force le slave a sortir des donnee
 412   2            while(!SDA)
 413   2            {
 414   3               // Provide clock pulses to allow the slave to advance out
 415   3               // of its current state. This will allow it to release SDA.
 416   3               SCL = 0;                         // Drive the clock low
 417   3               for(i = 0; i < 100; i++);        // Hold the clock low
 418   3               SCL = 1;                         // Release the clock
 419   3               for(i = 0; i < 100; i++);        // Hold the clock low
 420   3            }
 421   2            P0SKIP    = 0x00;//Enleve les skip de pin SDA et SCL
 422   2            XBR0      = 0x05;//reactive l'i2c
 423   2         }
 424   1      }
 425          
 426          /*---------------------------------------------------------------------------*-
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 8   

 427          configMCP23008()
 428          -----------------------------------------------------------------------------
 429          Descriptif: 
 430          Entree    : unsigned char input (0 ... 255) - choix de pins a mettre en sortie
 431          Sortie    : --
 432          -*---------------------------------------------------------------------------*/
 433          void configMCP23008(unsigned char input)
 434          {
 435   1         gTarget = MCP23008_ADDR;       // gTarget the Slave for next SMBus transfer
 436   1         gSMBDataOUT[0]  = MCP23008_IODIR;
 437   1         gSMBDataOUT[1]  = input;       // Set as INPUT
 438   1         gSMBNumBytesToWR = 2;
 439   1         SMB_Write();  // Initiate SMBus write
 440   1      }
 441          
 442          /*---------------------------------------------------------------------------*-
 443          read_i2c_port()
 444          -----------------------------------------------------------------------------
 445          Descriptif: Lis le port du MCP23008
 446          Entree    : --
 447          Sortie    : unsigend char (0 ... 255)
 448          -*---------------------------------------------------------------------------*/
 449          unsigned char read_i2c_port()
 450          {
 451   1         while(SMB_BUSY);
 452   1         gTarget = MCP23008_ADDR;
 453   1         gSMBDataOUT[0]  = MCP23008_GPIO;
 454   1         gSMBNumBytesToWR = 1;
 455   1         SMB_Write();  // Initiate SMBus write
 456   1         while(SMB_BUSY);
 457   1         gTarget = MCP23008_ADDR;
 458   1         gSMBNumBytesToRD = 1;
 459   1         SMB_Read();  // Initiate SMBus write
 460   1         return gSMBDataIN[0];
 461   1      }
 462          
 463          /*---------------------------------------------------------------------------*-
 464          setMotorRA()
 465          -----------------------------------------------------------------------------
 466          Descriptif: Applique une vitesse predefinit au moteur et une direction
 467          Entree    : 
 468                      - unsigned char vitesse (0 ... 10)
 469                      - bit direction         (0 ... 1)
 470          Sortie    : --
 471          -*---------------------------------------------------------------------------*/
 472          void setMotorRA(unsigned char vitesse,bit direction)
 473          {
 474   1         unsigned int i=0;
 475   1         TR0=0;
 476   1         STEP_RA=0;
 477   1         //for(i=0;i<500;i++);//voire figure 1
 478   1         DIR_RA=direction;
 479   1         //for(i=0;i<;i++);//voire figure 1
 480   1         switch(vitesse)
 481   1         {
 482   2            case VITESSE_RA_SIDERAL://suivi sideral
 483   2               gVitesseRAH=VITESSE_RA_SIDERAL_HIGH;
 484   2               gVitesseRAL=VITESSE_RA_SIDERAL_LOW;
 485   2            break;
 486   2            case VITESSE_RA_LUNE://suivi Lune
 487   2               gVitesseRAH=VITESSE_RA_LUNE_HIGH;
 488   2               gVitesseRAL=VITESSE_RA_LUNE_LOW;
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 9   

 489   2            break;
 490   2            case VITESSE_RA_SOLEIL://suivi Soleil-Planete generale
 491   2               gVitesseRAH=VITESSE_RA_SOLEIL_HIGH;//
 492   2               gVitesseRAL=VITESSE_RA_SOLEIL_LOW;
 493   2            break;
 494   2            case VITESSE_RA_SATURNE://suivi Soleil-Planete generale
 495   2               gVitesseRAH=VITESSE_RA_SATURNE_HIGH;//
 496   2               gVitesseRAL=VITESSE_RA_SATURNE_LOW;
 497   2            break;
 498   2            case VITESSE_RA_JUPITER://suivi Soleil-Planete generale
 499   2               gVitesseRAH=VITESSE_RA_JUPITER_HIGH;//
 500   2               gVitesseRAL=VITESSE_RA_JUPITER_LOW;
 501   2            break;
 502   2            case VITESSE_RA_ISS://suivi ISS
 503   2               gVitesseRAH=VITESSE_RA_ISS_HIGH;
 504   2               gVitesseRAL=VITESSE_RA_ISS_LOW;
 505   2            break;
 506   2            case VITESSE_X05://x0,5
 507   2               DIR_RA=0;
 508   2               if(direction==0)
 509   2               {
 510   3                  gVitesseRAH=VITESSE_RA_X1_5_HIGH;
 511   3                  gVitesseRAL=VITESSE_RA_X1_5_HIGH;
 512   3               }
 513   2               else
 514   2               {
 515   3                  gVitesseRAH=VITESSE_RA_X05_HIGH;
 516   3                  gVitesseRAL=VITESSE_RA_X05_LOW;
 517   3               }
 518   2            break;
 519   2            case VITESSE_X2://x2
 520   2               gVitesseRAH=VITESSE_RA_X2_HIGH;
 521   2               gVitesseRAL=VITESSE_RA_X2_LOW;
 522   2            break;
 523   2            case VITESSE_X8://x8
 524   2               gVitesseRAH=VITESSE_RA_X8_HIGH;
 525   2               gVitesseRAL=VITESSE_RA_X8_LOW;
 526   2            break;
 527   2            case VITESSE_X16://x16
 528   2               gVitesseRAH=VITESSE_RA_X16_HIGH;
 529   2               gVitesseRAL=VITESSE_RA_X16_LOW;
 530   2            break;
 531   2            case VITESSE_MAX://max
 532   2               gVitesseRAH=VITESSE_RA_MAX_HIGH;
 533   2               gVitesseRAL=VITESSE_RA_MAX_LOW;
 534   2            break;
 535   2            default://suivi sideral
 536   2               gVitesseRAH=VITESSE_RA_SIDERAL_HIGH;
 537   2               gVitesseRAL=VITESSE_RA_SIDERAL_LOW;      
 538   2            break;
 539   2         }
 540   1         TH0=gVitesseRAH ;//Charge la valeur dans le registre MSB du timer 0
 541   1         TL0=gVitesseRAL;//Charge la valeur dans le registre LSB du timer 0
 542   1         TR0=1;
 543   1      }
 544          
 545          /*---------------------------------------------------------------------------*-
 546          setMotorDEC()
 547          -----------------------------------------------------------------------------
 548          Descriptif: Applique une vitesse predefinit au moteur et une direction
 549          Entree    :
 550                      - unsigned char vitesse (6 ... 10)
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 10  

 551                      - bit direction         (0 ... 1)
 552          Sortie    : --
 553          -*---------------------------------------------------------------------------*/
 554          void setMotorDEC(unsigned char vitesse,bit direction)
 555          {
 556   1         unsigned int i=0;
 557   1         SFRPAGE   = CONFIG_PAGE;
 558   1         TMR4CN&=~0x04;
 559   1         SFRPAGE   = LEGACY_PAGE;
 560   1         //for(i=0;i<50000;i++);//voire figure 1
 561   1         NSLEEP_DEC=1;//Attention il faut 1.7ms au chip pour se rallumer
 562   1         STEP_DEC=0;
 563   1         DIR_DEC=direction;
 564   1         //for(i=0;i<50000;i++);//voire figure 1
 565   1         switch(vitesse)
 566   1         {
 567   2            case VITESSE_X05://x0,5
 568   2               gVitesseDEC=VITESSE_DEC_X05;
 569   2               SFRPAGE   = CONFIG_PAGE;
 570   2               TMR4CN|=0x04;
 571   2               SFRPAGE   = LEGACY_PAGE;
 572   2            break;
 573   2            case VITESSE_X2://x2
 574   2               gVitesseDEC=VITESSE_DEC_X2;
 575   2               SFRPAGE   = CONFIG_PAGE;
 576   2               TMR4CN|=0x04;
 577   2               SFRPAGE   = LEGACY_PAGE;
 578   2            break;
 579   2            case VITESSE_X8://x8
 580   2               gVitesseDEC=VITESSE_DEC_X8;
 581   2               SFRPAGE   = CONFIG_PAGE;
 582   2               TMR4CN|=0x04;
 583   2               SFRPAGE   = LEGACY_PAGE;
 584   2            break;
 585   2            case VITESSE_X16://x16
 586   2               gVitesseDEC=VITESSE_DEC_X16;
 587   2               SFRPAGE   = CONFIG_PAGE;
 588   2               TMR4CN|=0x04;
 589   2               SFRPAGE   = LEGACY_PAGE;
 590   2            break;
 591   2            case VITESSE_MAX://max
 592   2               gVitesseDEC=VITESSE_DEC_MAX;
 593   2               SFRPAGE   = CONFIG_PAGE;
 594   2               TMR4CN|=0x04;
 595   2               SFRPAGE   = LEGACY_PAGE;
 596   2            break;
 597   2            default://suivi sideral
 598   2              stopMotorDec(); 
 599   2            break;
 600   2         }
 601   1      }
 602          
 603          /*---------------------------------------------------------------------------*-
 604          stopMotorDec()
 605          -----------------------------------------------------------------------------
 606          Descriptif: Stop le moteur de declinaison et met le drv8825 en sommeil
 607          Entree    : --
 608          Sortie    : --
 609          -*---------------------------------------------------------------------------*/
 610          void stopMotorDec()
 611          {
 612   1         SFRPAGE   = CONFIG_PAGE;
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 11  

 613   1         TMR4CN&=~0x04;
 614   1         SFRPAGE   = LEGACY_PAGE;
 615   1         NSLEEP_DEC=0;
 616   1      }
 617          
 618          /*---------------------------------------------------------------------------*-
 619          decodeUartRaspberryPi()
 620          -----------------------------------------------------------------------------
 621          Descriptif: Decode les message envoyer par la raspberry PI
 622          Entree    : -- (Utilisation de varible globale)
 623          Sortie    : --
 624          -*---------------------------------------------------------------------------*/
 625          void decodeUartRaspberryPi()
 626          {
 627   1         if((gUart0Rx[0]=='R')&&(gUart0Rx[1]=='A'))
 628   1         {
 629   2            if((gUart0Rx[2]=='+'))
 630   2            {
 631   3               setMotorRA(gVitesseDeplacement,gDirRa);
 632   3            }
 633   2            else if (gUart0Rx[2]=='-')
 634   2            {
 635   3               setMotorRA(gVitesseDeplacement,!gDirRa);
 636   3            }
 637   2            else//=='0'
 638   2            {
 639   3               setMotorRA(gAstrSuivi,gDirRa);
 640   3            }
 641   2         }
 642   1         else if((gUart0Rx[0]=='D')&&(gUart0Rx[1]=='E')&&(gUart0Rx[2]=='C'))
 643   1         {
 644   2            if((gUart0Rx[3]=='+'))
 645   2            {
 646   3               setMotorDEC(gVitesseDeplacement,gDirDec);
 647   3            }
 648   2            else if (gUart0Rx[3]=='-')
 649   2            {
 650   3               setMotorDEC(gVitesseDeplacement,!gDirDec);
 651   3            }
 652   2            else//=='0'
 653   2            {
 654   3               stopMotorDec();
 655   3            }
 656   2         }
 657   1         else//Ne reconnait pas la commande, fais suivre au slave
 658   1         {
 659   2            //gUart1Tx[0]
 660   2            strcpy(gUart1Tx,gUart0Rx);
 661   2            SCON1|=0x02;
 662   2         }
 663   1      }
 664          
 665          /*---------------------------------------------------------------------------*-
 666             UART_Init ()
 667            -----------------------------------------------------------------------------
 668             Descriptif: Configure l'UART par ces valeur par defaut
 669                         (il ne fait rien)
 670             Entr�e    : --
 671             Sortie    : --
 672          -*---------------------------------------------------------------------------*/
 673          void UART_Init()
 674          {
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 12  

 675   1          SCON0     = 0x10;
 676   1          //SBRLL1    = 0x3C;
 677   1          //SBRLH1    = 0xF6;
 678   1          //SCON1     = 0x10;
 679   1          //SBCON1    = 0x43;
 680   1         
 681   1         //57600 Uart1
 682   1          SBRLL1    = 0x5F;
 683   1          SBRLH1    = 0xFE;
 684   1          SCON1     = 0x10;
 685   1          SBCON1    = 0x43;
 686   1         
 687   1         //115200 Uart1
 688   1      // SBRLL1    = 0x30;
 689   1      //    SBRLH1    = 0xFF;
 690   1      //    SCON1     = 0x10;
 691   1      //    SBCON1    = 0x43;
 692   1      }
 693          
 694          /*---------------------------------------------------------------------------*-
 695          Init_int ()
 696          -----------------------------------------------------------------------------
 697          Descriptif:
 698          Interruption 0 : P0.6 - Descendant
 699          Interruption 1 : P0.7 - Descendant
 700          Entree    : --
 701          Sortie    : --
 702          -*---------------------------------------------------------------------------*/
 703          void Init_int()
 704          {
 705   1         EX0=0;//Autorise l'interruption externe 0
 706   1         EX1=0;//Autorise l'interruption externe 1
 707   1         IT0=1;//interruption 0 sur flanc
 708   1         IT1=1;//interruption 1 sur flanc
 709   1         IT01CF= IT01CF &~ 0xFF;//Clear le registre des interruption
 710   1                               // +-------- INT1 Polarite
 711   1                               // |+++----- Selection du canal P0.x de l'interruption 1
 712   1                               // ||||+---- INT0 Polarite
 713   1                               // |||||+++- Selection du canal P0.x de l'interruption 0
 714   1                               // ||||||||  (000: Select P0.0)
 715   1                               // ||||||||  ...
 716   1                               // ||||||||  ...
 717   1                               // ||||||||  (111: Select P0.7)  
 718   1         IT01CF= IT01CF | 0x76;// 01110110
 719   1      
 720   1         IE0=0; IE0=0; IE0=0;//clear du flag d'interruption 0 (3* pour eviter les bug)
 721   1         IE1=0; IE1=0; IE1=0;//clear du flag d'interruption 1 (3* pour eviter les bug)
 722   1         EX0=1;//Active l'interruption 0
 723   1         EX1=1;//Active l'interruption 1
 724   1      }
 725          
 726          /*---------------------------------------------------------------------------*-
 727          TimerInit ()
 728          -----------------------------------------------------------------------------
 729          Descriptif:
 730          Timer 0 : Mode 16bit - Prediv 48 - vitesse definit par gVitesseRAH-L
 731          Timer 1 : Mode 8bit - Prediv 48 - baudrate 57600
 732          Entree    : --
 733          Sortie    : --
 734          -*---------------------------------------------------------------------------*/
 735          void TimerInit()
 736          {
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 13  

 737   1         //Timer 0 et 1
 738   1         TR0 = 0;//Stop le timer 0
 739   1         TR1 = 0;
 740   1         ET0 = 0;//Desactive l'interruption du timer 0
 741   1         ET1=0;
 742   1         TMOD &= ~0x0F;//Clear le registre du mode 0
 743   1                      // +-------- Timer 1 Gate Control
 744   1                      // |+------- Counter/Timer1 Select
 745   1                      // ||++----- choix du mode du timer 1
 746   1                      // ||||+---- Timer 0 Gate Control
 747   1                      // |||||+--- Counter/Timer0 Select
 748   1                      // ||||||++- choix du mode du timer 0
 749   1                      // ||||||||  (00 : Mode 0, 13-bit Counter/Timer)
 750   1                      // ||||||||  (01 : Mode 1, 16-bit Counter/Timer)
 751   1                      // ||||||||  (10 : Mode 2, 8-bit Counter/Timer with Auto-Reload)
 752   1                      // ||||||||  (11 : Mode 3, Two 8-bit Counter/Timers)  
 753   1         TMOD |= 0x21;// 00000001
 754   1         CKCON &= ~0x07;//clear les bit de selection pour les timer 0 et 1 et le prescalaire
 755   1                       // +-------- Timer 3 High Byte Clock Select.
 756   1                       // |+------- Timer 3 Low Byte Clock Select.
 757   1                       // ||+------ Timer 2 High Byte Clock Select
 758   1                       // |||+----- Timer 2 Low Byte Clock Select.
 759   1                       // ||||+---- Timer 1 Clock Select.
 760   1                       // |||||+--- Timer 0 Clock Select.
 761   1                       // ||||||++- Timer 0/1 Prescale Bits.
 762   1                       // ||||||||  (00: System clock divided by 12)
 763   1                       // ||||||||  (01: System clock divided by 4)
 764   1                       // ||||||||  (10: System clock divided by 48)
 765   1                       // ||||||||  (11: External clock divided by 8 (synchronized with the system clock))  
 766   1         CKCON |= 0x02;// 00000010
 767   1         TH0=gVitesseRAH;//Charge la valeur dans le registre MSB du timer 0
 768   1         TL0=gVitesseRAL;//Charge la valeur dans le registre LSB du timer 0
 769   1         TH1=TL1=BAUD_UART0;//Charge la valeur dans le registre LSB du timer 0
 770   1         TF0 = 0;//clear le flag d'interruption du timer 0
 771   1         TF1 = 0;
 772   1         ET0 = 1;//Autorise l'interruption du timer 0
 773   1         //ET1 = 1;
 774   1         
 775   1         //Init Timer 4 
 776   1         SFRPAGE   = CONFIG_PAGE;
 777   1         TMR4CN = 0x00;//Mode 16 bit auto reload
 778   1         TMR4RLH=0xF7;
 779   1         TMR4RLL=0x8A;
 780   1         SFRPAGE   = LEGACY_PAGE;
 781   1      }
 782          
 783          /*---------------------------------------------------------------------------*-
 784             ClockInit ()
 785            -----------------------------------------------------------------------------
 786             Descriptif: Initialisation du mode de fonctionnement du clock syst�me 
 787                   choix : SYSCLK : oscillateur HF interne � 48 MHz
 788          
 789             Entr�e    : --
 790             Sortie    : --
 791          -*---------------------------------------------------------------------------*/
 792          void ClockInit()
 793          {  
 794   1         
 795   1                           // +--------- clock interne LF
 796   1                           // | (1 : oscillateur LF : enable)
 797   1                           // | (0 : oscillateur LF: desable)
 798   1                           // |+-------- en lecture seule 1 : signal que oscillateur 
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 14  

 799   1                           // ||         interne fonctionne � sa valeur de prog.
 800   1                           // ||++++---- r�glage fin de la fr�quence de l'osc. LF
 801   1                           // ||||||++-- choix du diviseur :
 802   1                           // ||||||||       (00 : Osc LF /8 -> f = 10 KHz)
 803   1                           // ||||||||       (01 : Osc LF /4 -> f = 20 KHz)
 804   1                           // ||||||||       (10 : Osc LF /2 -> f = 40 KHz)
 805   1                           // ||||||||       (11 : Osc LF /1 -> f = 80 KHz)
 806   1         OSCLCN |= 0x00;   // 00000000 
 807   1      
 808   1                           // +--------- non utilis�
 809   1                           // |+++------ S�lection du clock USB 
 810   1                           // ||||           (010 : Oscil ext. : limiter la conso.)
 811   1                           // ||||+----- clock out select
 812   1                           // |||||          (0 : sortie sysclk non synchronis�e)
 813   1                           // |||||          (1 : sortie sysclk synchronis�e)
 814   1                           // |||||+++-- choix du clock syst�me
 815   1                           // ||||||||       (000 : Oscil interne 48/4  = 1.5, 3, 6 ou
 816   1                           // ||||||||              12 MHz selon le choix du diviseur 
 817   1                           // ||||||||              dans OSCICN
 818   1                           // ||||||||       (001 : Oscil externe  = x  MHz)
 819   1                           // ||||||||       (010 : Oscil interne 48/2 = 24 MHz)
 820   1                           // ||||||||       (011 : Oscil interne 48/1 = 48 MHz)    
 821   1                           // ||||||||       (100 : Oscil interne LF = 80 KHz max)   
 822   1                           // ||||||||       (101 � 111 : r�serv�s)   
 823   1         CLKSEL = 0x03;    // 00000011  
 824   1      
 825   1                           // +--------- clock interne HF
 826   1                           // |              (1 : oscillateur LF : enable)
 827   1                           // |              (0 : oscillateur LF: desable)
 828   1                           // |+-------- en lecture seule 1 : signal que oscillateur 
 829   1                           // ||              interne fonctionne � sa valeur de prog.
 830   1                           // ||+------- 1 : suspend l'oscillateur interne
 831   1                           // |||+++---- non utilis�s
 832   1                           // ||||||++-- choix du diviseur :
 833   1                           // ||||||||       (00 : 12/8 -> f =  1.5 MHz)
 834   1                           // ||||||||       (01 : 12/4 -> f =  3   MHz)
 835   1                           // ||||||||       (10 : 12/2 -> f =  6   MHz)
 836   1                           // ||||||||       (11 : 12/1 -> f = 12   MHz)
 837   1         OSCICN = 0xC3;    // 11000011 
 838   1         
 839   1         FLSCL = 0x90;     // A utiliser si le clock system est � 48 MHz
 840   1      
 841   1      } // ClockInit ----------------------------------------------------------------
 842          
 843          
 844          //-----------------------------------------------------------------------------
 845          // SMBus_Init
 846          //-----------------------------------------------------------------------------
 847          //
 848          // Return Value : None
 849          // Parameters   : None
 850          //
 851          // SMBus configured as follows:
 852          // - SMBus enabled
 853          // - Slave mode inhibited
 854          // - Timer2 used as clock source. The maximum SCL frequency will be
 855          //   approximately 1/3 the Timer1 overflow rate
 856          // - Setup and hold time extensions enabled
 857          // - Bus Free and SCL Low timeout detection enabled
 858          //
 859          void SMBus_Init (void)
 860          {
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 15  

 861   1         SMB0CF = 0x5E;                      // Use Timer2 overflows as SMBus clock
 862   1                                             // source;
 863   1                                             // Disable slave mode;
 864   1                                             // Enable setup & hold time
 865   1                                             // extensions;
 866   1                                             // Enable SMBus Free timeout detect;
 867   1                                             // Enable SCL low timeout detect;
 868   1      
 869   1         SMB0CF |= 0x80;                     // Enable SMBus;
 870   1      }
 871          
 872          
 873          //-----------------------------------------------------------------------------
 874          // Timer2_Init
 875          //-----------------------------------------------------------------------------
 876          //
 877          // Return Value : None
 878          // Parameters   : None
 879          //
 880          // Timer2 configured as the SMBus clock source as follows:
 881          // - Timer2 in 8-bit auto-reload mode
 882          // - SYSCLK or SYSCLK / 4 as Timer1 clock source
 883          // - Timer2 overflow rate => 3 * SMB_FREQUENCY
 884          // - The resulting SCL clock rate will be ~1/3 the Timer2 overflow rate
 885          // - Timer2 enabled
 886          //
 887          void Timer2_Init (void)
 888          {
 889   1         TMR2CN    |= 0x0C;//0x0C
 890   1         TMR2RLH   |= 0x7B;//0x7B
 891   1      }
 892          
 893          //-----------------------------------------------------------------------------
 894          // Timer3_Init
 895          //-----------------------------------------------------------------------------
 896          //
 897          // Return Value : None
 898          // Parameters   : None
 899          //
 900          // Timer3 configured for use by the SMBus low timeout detect feature as
 901          // follows:
 902          // - Timer3 in 16-bit auto-reload mode
 903          // - SYSCLK/12 as Timer3 clock source
 904          // - Timer3 reload registers loaded for a 25ms overflow period
 905          // - Timer3 pre-loaded to overflow after 25ms
 906          // - Timer3 enabled
 907          //
 908          void Timer3_Init (void)
 909          {
 910   1         TMR3CN = 0x00;                      // Timer3 configured for 16-bit auto-
 911   1                                             // reload, low-byte interrupt disabled
 912   1      
 913   1         CKCON &= ~0x40;                     // Timer3 uses SYSCLK/12
 914   1      
 915   1         TMR3RL = -(SYSCLK/12/40);           // Timer3 configured to overflow after
 916   1         TMR3 = TMR3RL;                      // ~25ms (for SMBus low timeout detect):
 917   1                                             // 1/.025 = 40
 918   1      
 919   1         EIE1 |= 0x80;                       // Timer3 interrupt enable
 920   1         TMR3CN |= 0x04;                     // Start Timer3
 921   1      }
 922          
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 16  

 923          //-----------------------------------------------------------------------------
 924          // SMBus Interrupt Service Routine (ISR)
 925          //-----------------------------------------------------------------------------
 926          //
 927          // SMBus ISR state machine
 928          // - Master only implementation - no slave or arbitration states defined
 929          // - All incoming data is written to global variable array <gSMBDataIN>
 930          // - All outgoing data is read from global variable array <gSMBDataOUT>
 931          //
 932          void SMBus_ISR (void) interrupt 7
 933          {
 934   1         bit FAIL = 0;                       // Used by the ISR to flag failed
 935   1                                             // transfers
 936   1      
 937   1         static unsigned char sent_byte_counter;
 938   1         static unsigned char rec_byte_counter;
 939   1      
 940   1         if (ARBLOST0 == 0)                   // Check for errors
 941   1         {
 942   2            // Normal operation
 943   2            switch (SMB0CN & 0xF0)           // Status vector
 944   2            {
 945   3               // Master Transmitter/Receiver: START condition transmitted.
 946   3               case SMB_MTSTA:
 947   3                  SMB0DAT = gTarget;          // Load address of the gTarget slave
 948   3                  SMB0DAT &= 0xFE;           // Clear the LSB of the address for the
 949   3                                             // R/W bit
 950   3                  SMB0DAT |= SMB_RW;         // Load R/W bit
 951   3                  STA0 = 0;                   // Manually clear START bit
 952   3                  rec_byte_counter = 1;      // Reset the counter
 953   3                  sent_byte_counter = 1;     // Reset the counter
 954   3                  break;
 955   3      
 956   3               // Master Transmitter: Data byte transmitted
 957   3               case SMB_MTDB:
 958   3                  if (ACK0)                   // Slave ACK0?
 959   3                  {
 960   4                     if (SMB_RW == WRITE)    // If this transfer is a WRITE,
 961   4                     {
 962   5                        if (sent_byte_counter <= gSMBNumBytesToWR)
 963   5                        {
 964   6                           // send data byte
 965   6                           SMB0DAT = gSMBDataOUT[sent_byte_counter-1];
 966   6                           sent_byte_counter++;
 967   6                        }
 968   5                        else
 969   5                        {
 970   6                           STO0 = 1;          // Set STO0 to terminate transfer
 971   6                           SMB_BUSY = 0;     // And free SMBus interface
 972   6                        }
 973   5                     }
 974   4                     else {}                 // If this transfer is a READ,
 975   4                                             // proceed with transfer without
 976   4                                             // writing to SMB0DAT (switch
 977   4                                             // to receive mode)
 978   4      
 979   4      
 980   4                  }
 981   3                  else                       // If slave NACK,
 982   3                  {
 983   4                     STO0 = 1;                // Send STOP condition, followed
 984   4                     STA0 = 1;                // By a START
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 17  

 985   4                     NUM_ERRORS++;           // Indicate error
 986   4                  }
 987   3                  break;
 988   3      
 989   3               // Master Receiver: byte received
 990   3               case SMB_MRDB:
 991   3                  if (rec_byte_counter < gSMBNumBytesToRD)
 992   3                  {
 993   4                     gSMBDataIN[rec_byte_counter-1] = SMB0DAT; // Store received
 994   4                                                                // byte
 995   4                     ACK0 = 1;                // Send ACK0 to indicate byte received
 996   4                     rec_byte_counter++;     // Increment the byte counter
 997   4                  }
 998   3                  else
 999   3                  {
1000   4                     gSMBDataIN[rec_byte_counter-1] = SMB0DAT; // Store received
1001   4                                                                // byte
1002   4                     SMB_BUSY = 0;           // Free SMBus interface
1003   4                     ACK0 = 0;                // Send NACK to indicate last byte
1004   4                                             // of this transfer
1005   4      
1006   4                     STO0 = 1;                // Send STOP to terminate transfer
1007   4                  }
1008   3                  break;
1009   3      
1010   3               default:
1011   3                  FAIL = 1;                  // Indicate failed transfer
1012   3                                             // and handle at end of ISR
1013   3                  break;
1014   3      
1015   3            } // end switch
1016   2         }
1017   1         else
1018   1         {
1019   2            // ARBLOST = 1, error occurred... abort transmission
1020   2            FAIL = 1;
1021   2         } // end ARBLOST if
1022   1      
1023   1         if (FAIL)                           // If the transfer failed,
1024   1         {
1025   2            SMB0CF &= ~0x80;                 // Reset communication
1026   2            SMB0CF |= 0x80;
1027   2            STA0 = 0;
1028   2            STO0 = 0;
1029   2            ACK0 = 0;
1030   2      
1031   2            SMB_BUSY = 0;                    // Free SMBus
1032   2      
1033   2            FAIL = 0;
1034   2            //LED = 0;
1035   2      
1036   2            NUM_ERRORS++;                    // Indicate an error occurred
1037   2         }
1038   1      
1039   1         SI0 = 0;                             // Clear interrupt flag
1040   1      }
1041          
1042          //-----------------------------------------------------------------------------
1043          // Timer3 Interrupt Service Routine (ISR)
1044          //-----------------------------------------------------------------------------
1045          //
1046          // A Timer3 interrupt indicates an SMBus SCL low timeout.
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 18  

1047          // The SMBus is disabled and re-enabled here
1048          //
1049          void Timer3_ISR (void) interrupt 14
1050          {
1051   1         SMB0CF &= ~0x80;                    // Disable SMBus
1052   1         SMB0CF |= 0x80;                     // Re-enable SMBus
1053   1         TMR3CN &= ~0x80;                    // Clear Timer3 interrupt-pending
1054   1                                             // flag
1055   1         STA0 = 0;
1056   1         SMB_BUSY = 0;                       // Free SMBus
1057   1      }
1058          
1059          //-----------------------------------------------------------------------------
1060          // Support Functions
1061          //-----------------------------------------------------------------------------
1062          
1063          //-----------------------------------------------------------------------------
1064          // SMB_Write
1065          //-----------------------------------------------------------------------------
1066          //
1067          // Return Value : None
1068          // Parameters   : None
1069          //
1070          // Writes a single byte to the slave with address specified by the <gTarget>
1071          // variable.
1072          // Calling sequence:
1073          // 1) Write gTarget slave address to the <gTarget> variable
1074          // 2) Write outgoing data to the <gSMBDataOUT> variable array
1075          // 3) Call SMB_Write()
1076          //
1077          void SMB_Write (void)
1078          {
1079   1         while (SMB_BUSY);                   // Wait for SMBus to be free.
1080   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
1081   1         SMB_RW = 0;                         // Mark this transfer as a WRITE
1082   1         STA0 = 1;                            // Start transfer
1083   1      }
1084          
1085          //-----------------------------------------------------------------------------
1086          // SMB_Read
1087          //-----------------------------------------------------------------------------
1088          //
1089          // Return Value : None
1090          // Parameters   : None
1091          //
1092          // Reads a single byte from the slave with address specified by the <gTarget>
1093          // variable.
1094          // Calling sequence:
1095          // 1) Write gTarget slave address to the <gTarget> variable
1096          // 2) Call SMB_Write()
1097          // 3) Read input data from <gSMBDataIN> variable array
1098          //
1099          void SMB_Read (void)
1100          {
1101   1         while (SMB_BUSY);                   // Wait for bus to be free.
1102   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
1103   1         SMB_RW = 1;                         // Mark this transfer as a READ
1104   1      
1105   1         STA0 = 1;                            // Start transfer
1106   1      
1107   1         while (SMB_BUSY);                   // Wait for transfer to complete
1108   1      }
C51 COMPILER V9.56.0.0   MASTER_TELESCOPE_V3                                               06/07/2019 09:06:16 PAGE 19  

1109          
1110          
1111          /*---------------------------------------------------------------------------*-
1112             PortInit ()
1113            -----------------------------------------------------------------------------
1114             Descriptif: autorise le fonctionnement du crossbar et de l'uart0
1115             Entr�e    : --
1116             Sortie    : --
1117          -*---------------------------------------------------------------------------*/
1118          void PortInit () 
1119          {
1120   1         // P0.0  -  SDA (SMBus0), Open-Drain, Digital
1121   1          // P0.1  -  SCL (SMBus0), Push-Pull,  Digital
1122   1          // P0.2  -  TX1 (UART1), Push-Pull,  Digital
1123   1          // P0.3  -  RX1 (UART1), Open-Drain, Digital
1124   1          // P0.4  -  TX0 (UART0), Push-Pull,  Digital
1125   1          // P0.5  -  RX0 (UART0), Open-Drain, Digital
1126   1          // P0.6  -  Unassigned,  Open-Drain, Digital
1127   1          // P0.7  -  Unassigned,  Open-Drain, Digital
1128   1      
1129   1          // P1.0  -  Skipped,     Push-Pull,  Digital
1130   1          // P1.1  -  Skipped,     Push-Pull,  Digital
1131   1          // P1.2  -  Skipped,     Push-Pull,  Digital
1132   1          // P1.3  -  Skipped,     Open-Drain, Digital
1133   1          // P1.4  -  Skipped,     Push-Pull,  Digital
1134   1          // P1.5  -  Skipped,     Push-Pull,  Digital
1135   1          // P1.6  -  Skipped,     Push-Pull,  Digital
1136   1          // P1.7  -  Skipped,     Open-Drain, Digital
1137   1      
1138   1          // P2.0  -  Skipped,     Open-Drain, Digital
1139   1          // P2.1  -  Skipped,     Open-Drain, Digital
1140   1          // P2.2  -  Skipped,     Open-Drain, Digital
1141   1          // P2.3  -  Skipped,     Open-Drain, Digital
1142   1          // P2.4  -  Unassigned,  Open-Drain, Digital
1143   1          // P2.5  -  Unassigned,  Open-Drain, Digital
1144   1          // P2.6  -  Unassigned,  Open-Drain, Digital
1145   1          // P2.7  -  Unassigned,  Open-Drain, Digital
1146   1      
1147   1          // P3.0  -  Unassigned,  Open-Drain, Digital
1148   1      
1149   1          P0MDOUT   = 0x16;
1150   1          P1MDOUT   = 0xDD;//0xFF = schema
1151   1          P1SKIP    = 0xFF;
1152   1          P2SKIP    = 0x0F;
1153   1          XBR0      |= 0x05;
1154   1          XBR1      |= 0x40;
1155   1          XBR2      |= 0x01;
1156   1      
1157   1      } // PortInit ----------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2041    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     40    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     41    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     11    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

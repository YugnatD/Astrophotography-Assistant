C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MASTER_TELESCOPE_V3
OBJECT MODULE PLACED IN .\Objects\Master_Telescope V3.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Master_Telescope V3.c OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(
                    -.\Listings\Master_Telescope V3.lst) TABS(2) OBJECT(.\Objects\Master_Telescope V3.obj)

line level    source

   1          /*===========================================================================*=
   2            Master_Telescope - Tanguy Dietrich
   3            =============================================================================
   4             Descriptif: 
   5             Gestion de moteur d'une monture NEQ5.
   6             Le moteur R.A a une vitesse constante correspondant a la vitesse sideral.
   7             Le moteur DEC est activer lorsque la pin p2.2 ou P2.3(ST4) sont a 0
   8             Le tout est commander avec un port ST4
   9          =*===========================================================================*/
  10          
  11          #include <reg51f380.h>     // registres 51f38C
  12          #include "Vitesse_Moteur.h"
  13          #include "Delay48M.h"
  14          #include "SmBus0.h"
  15          #include "string.h"
  16          
  17          #define CONFIG_PAGE 0x0F
  18          #define LEGACY_PAGE 0x00
  19          #define BAUD_UART0 221 //247=57600 
  20          
  21          //PCB
  22          sbit STEP_RA = P1^3;
  23          sbit DIR_RA = P1^2;
  24          sbit NSLEEP_RA = P1^0;
  25          sbit NFAULT_RA = P1^1;
  26          
  27          sbit STEP_DEC = P1^7;
  28          sbit DIR_DEC = P1^6;
  29          sbit NSLEEP_DEC = P1^4;
  30          sbit NFAULT_DEC = P1^5;
  31          
  32          sbit ST4_RA_NEG = P2^0;
  33          sbit ST4_RA_POS = P2^1;
  34          sbit ST4_DEC_NEG = P2^2;
  35          sbit ST4_DEC_POS = P2^3;
  36          
  37          sbit SDA = P0^0;
  38          sbit SCL = P0^1;
  39          
  40          
  41          // ==== FONCTIONS PROTOTYPES===================================================
  42          void ClockInit ();         // init. clock syst�me
  43          void PortInit ();          // init. config des ports
  44          void TimerInit();
  45          void Init_int();
  46          void SMBus_Init (void);
  47          void Timer3_Init (void);
  48          void Timer2_Init (void);
  49          void SMB_Write (void);
  50          void SMB_Read (void);
  51          void UART_Init();
  52          void decodeUartRaspberryPi();
  53          void setMotorRA(unsigned char vitesse,bit direction);
  54          void setMotorDEC(unsigned char vitesse,bit direction);
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 2   

  55          void stopMotorDec();
  56          void configMCP23008(unsigned char input);
  57          unsigned char read_i2c_port();
  58          void reset_i2c();
  59          // ==== MAIN ==================================================================
  60          
  61          //SMBus0
  62          unsigned char gSMBNumBytesToWR = 2; // Number of bytes to write
  63                                              // Master -> Slave
  64          unsigned char gSMBNumBytesToRD = 3; // Number of bytes to read
  65                                              // Master <- Slave
  66          
  67          // Global holder for SMBus data
  68          // All receive data is written here
  69          unsigned char gSMBDataIN[NUM_BYTES_MAX_RD];
  70          
  71          // Global holder for SMBus data.
  72          // All transmit data is read from here
  73          unsigned char gSMBDataOUT[NUM_BYTES_MAX_WR];
  74          
  75          unsigned char gTarget;                  // gTarget SMBus slave address
  76          
  77          bit SMB_BUSY;                          // Software flag to indicate when the
  78                                                 // SMB_Read() or SMB_Write() functions
  79                                                 // have claimed the SMBus
  80          
  81          bit SMB_RW;                            // Software flag to indicate the
  82                                                 // direction of the current transfer
  83          
  84          unsigned long NUM_ERRORS;              // Counter for the number of errors.
  85          
  86          
  87          
  88          
  89          //Gestion Moteur
  90          unsigned char gVitesseRAH=VITESSE_SIDERAL_HIGH;
  91          unsigned char gVitesseRAL=VITESSE_SIDERAL_LOW;
  92          unsigned char gVitesseDECH=VITESSE_SIDERAL_HIGH;
  93          unsigned char gVitesseDECL=VITESSE_SIDERAL_HIGH;
  94          //unsigned int gVitesseDEC=VITESSE_DEC_MAX;
  95          unsigned char gVitesseDeplacement=VITESSE_MAX;
  96          
  97          //Uart
  98          xdata unsigned char gUart0Tx[10]="";
  99          xdata unsigned char gUart0Rx[10];
 100          unsigned char gUart0NbrByteTx=0;
 101          unsigned char gUart0NbrByteRx=0;
 102          bit gUart0FlagReceive;
 103          
 104          xdata unsigned char gUart1Tx[10]="";
 105          xdata unsigned char gUart1Rx[10];
 106          unsigned char gUart1NbrByteTx=0;
 107          unsigned char gUart1NbrByteRx=0;
 108          bit gUart1FlagReceive;
 109          bit gDirRa=0;
 110          bit gDirDec=0;
 111          unsigned char gAstrSuivi=0;
 112          bit gFlagMovingRA=0;
 113          
 114          void main () 
 115          {
 116   1         unsigned char portExtender;
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 3   

 117   1        unsigned char memoAstreSuivi=0;
 118   1        bit waitEndMove=0;
 119   1         PCA0MD &= ~0x40;     // WDTE = 0 (disable watchdog timer)
 120   1         ClockInit ();        // init. clock syst�me
 121   1         PortInit ();         // init. config des ports
 122   1        SDA=1;
 123   1         reset_i2c();
 124   1         Init_int();
 125   1         Timer3_Init();                      // Configure Timer3 for use with SMBus
 126   1                                             // low timeout detect
 127   1         Timer2_Init();
 128   1      
 129   1         SMBus_Init ();                      // Configure and enable SMBus
 130   1         UART_Init();
 131   1         TimerInit();
 132   1         EA=1;//Autorise toutes les interruption
 133   1         EIE1      |= 0x81;
 134   1          EIE2      |= 0x12;
 135   1          IE        |= 0x97;
 136   1         TR0 = 1;//lance le timer 0
 137   1         TR1=1;
 138   1         NSLEEP_RA=1;//Active le chip drv8825
 139   1         NSLEEP_DEC=0;
 140   1         DIR_RA=0;
 141   1         DIR_DEC=0;
 142   1         
 143   1         SDA=1;
 144   1         Delay_1ms (20);
 145   1         configMCP23008(0xFF);
 146   1        portExtender=read_i2c_port();
 147   1         gAstrSuivi=(portExtender>>4);
 148   1        //memoAstreSuivi=gAstrSuivi;
 149   1         while (1)
 150   1         {
 151   2          memoAstreSuivi=gAstrSuivi;
 152   2            gVitesseDeplacement=(P2>>4)+VITESSE_X01;
 153   2            portExtender=read_i2c_port();
 154   2            gAstrSuivi=(portExtender>>4);
 155   2            gDirRa=(portExtender&0x04)>>2;
 156   2            gDirDec=(portExtender&0x08)>>3;
 157   2          
 158   2          if((memoAstreSuivi!=gAstrSuivi)||(waitEndMove==1))
 159   2          {
 160   3            waitEndMove=1;
 161   3            if(gFlagMovingRA==0)
 162   3            {
 163   4              setMotorRA(gAstrSuivi,gDirRa);
 164   4              waitEndMove=0;
 165   4            }
 166   3          }
 167   2          
 168   2            if((NFAULT_RA==0)&&(NSLEEP_RA==1))//probleme sur le DRV8825 de l'axe R.A
 169   2            {
 170   3               NSLEEP_RA=0;
 171   3               Delay_1ms (10);
 172   3               NSLEEP_RA=1;
 173   3               Delay_1ms (10);//1.7ms necessaire au rallumage
 174   3            }
 175   2            
 176   2            if((NFAULT_DEC==0)&&(NSLEEP_DEC==1))//probleme sur le DRV8825 de l'axe DEC
 177   2            {
 178   3               NSLEEP_DEC=0;//Eteint
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 4   

 179   3               Delay_1ms (10);
 180   3               NSLEEP_DEC=1;//Allume
 181   3               Delay_1ms (10);
 182   3            }
 183   2            
 184   2            if(gUart0FlagReceive)
 185   2            {
 186   3               gUart0FlagReceive=0;
 187   3            while(gUart0NbrByteTx!=0);
 188   3               decodeUartRaspberryPi();
 189   3            }
 190   2          
 191   2            if(gUart1FlagReceive)
 192   2            {
 193   3            while(gUart0NbrByteTx!=0);
 194   3            gUart1FlagReceive=0;
 195   3            strcpy(gUart0Tx,gUart1Rx);
 196   3            TI0=1;
 197   3            }
 198   2            
 199   2         } // End while (1)
 200   1      } // main =====================================================================
 201          
 202          //INTERRUPTION
 203          /*---------------------------------------------------------------------------*-
 204          interruption0()
 205          -----------------------------------------------------------------------------
 206          Descriptif: Fonction d'interruption INT0 vecteur 0
 207                      Pin :P0.6 - Descendant
 208          Entree    : --
 209          Sortie    : --
 210          -*---------------------------------------------------------------------------*/
 211          void interruption_ST4_RA() interrupt 0
 212          {
 213   1         IT01CF=IT01CF^0x08;
 214   1         if((!ST4_RA_POS)&&(!ST4_RA_NEG))
 215   1         {
 216   2            setMotorRA(gAstrSuivi,gDirRa);
 217   2          gFlagMovingRA=0;
 218   2         }
 219   1         else if((ST4_RA_POS)&&(ST4_RA_NEG))
 220   1         {
 221   2            setMotorRA(gAstrSuivi,gDirRa);
 222   2          gFlagMovingRA=0;
 223   2         }
 224   1         else if((ST4_RA_POS)&&(!ST4_RA_NEG))
 225   1         {
 226   2            setMotorRA(gVitesseDeplacement,!gDirRa);
 227   2          gFlagMovingRA=1;
 228   2         }
 229   1         else if((!ST4_RA_POS)&&(ST4_RA_NEG))
 230   1         {
 231   2            setMotorRA(gVitesseDeplacement,gDirRa);
 232   2          gFlagMovingRA=1;
 233   2         }
 234   1      }
 235          /*---------------------------------------------------------------------------*-
 236          interruption1()
 237          -----------------------------------------------------------------------------
 238          Descriptif: Fonction d'interruption 1 vecteur 2
 239                      Pin :P0.7 - Descendant
 240          Entree    : --
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 5   

 241          Sortie    : --
 242          -*---------------------------------------------------------------------------*/
 243          void interruption_ST4_DEC() interrupt 2
 244          {
 245   1         IT01CF=IT01CF^0x80;
 246   1         if((!ST4_DEC_POS)&&(!ST4_DEC_NEG))//00
 247   1         {
 248   2            stopMotorDec();
 249   2         }
 250   1         else if((ST4_DEC_POS)&&(ST4_DEC_NEG))//11
 251   1         {
 252   2            stopMotorDec();
 253   2         }
 254   1         else if((ST4_DEC_POS)&&(!ST4_DEC_NEG))//10
 255   1         {
 256   2            setMotorDEC(gVitesseDeplacement,gDirDec);
 257   2         }
 258   1         else if((!ST4_DEC_POS)&&(ST4_DEC_NEG))//01
 259   1         {
 260   2            setMotorDEC(gVitesseDeplacement,!gDirDec);
 261   2         }
 262   1      }
 263          
 264          /*---------------------------------------------------------------------------*-
 265          timer0()
 266          -----------------------------------------------------------------------------
 267          Descriptif: Fonction d'interruption Timer0 vecteur 1
 268                    Temporisation de 51,94milli
 269                    Mode : 16bit
 270          Entree    : --
 271          Sortie    : --
 272          -*---------------------------------------------------------------------------*/
 273          void timer0() interrupt 1
 274          {
 275   1         TR0=0;
 276   1         TH0=gVitesseRAH ;//Charge la valeur dans le registre MSB du timer 0
 277   1         TL0=gVitesseRAL;//Charge la valeur dans le registre LSB du timer 0
 278   1         TR0=1;
 279   1         STEP_RA=!STEP_RA;
 280   1      }
 281          
 282          ///*---------------------------------------------------------------------------*-
 283          //timer1()
 284          //-----------------------------------------------------------------------------
 285          //Descriptif: Fonction d'interruption Timer1 vecteur 3
 286          //          Mode : 8 bit 9600baud
 287          //Entree    : --
 288          //Sortie    : --
 289          //-*---------------------------------------------------------------------------*/
 290          //void timer1() interrupt 3
 291          //{
 292          //   
 293          //}
 294          
 295          /*---------------------------------------------------------------------------*-
 296          timer4()
 297          -----------------------------------------------------------------------------
 298          Descriptif: Fonction d'interruption Timer4 vecteur 19
 299                    Mode : 16bit autoreload
 300          Entree    : --
 301          Sortie    : --
 302          -*---------------------------------------------------------------------------*/
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 6   

 303          void timer4() interrupt 19
 304          {
 305   1         //static unsigned int cpt=0;
 306   1         SFRPAGE   = CONFIG_PAGE;
 307   1         TMR4CN &=~0xC0;//Clear pending flag
 308   1         TMR4CN &=~0x04;//arrette le timer
 309   1         TMR4RLH=gVitesseDECH;
 310   1         TMR4RLL=gVitesseDECL;
 311   1         TMR4CN|=0x04;//relance le timer
 312   1         SFRPAGE   = LEGACY_PAGE;
 313   1         STEP_DEC=!STEP_DEC;
 314   1      }
 315          /*---------------------------------------------------------------------------*-
 316          uart0()
 317          -----------------------------------------------------------------------------
 318          Descriptif: Fonction d'interruption de l'uart0 vecteur 4
 319          Entree    : --
 320          Sortie    : --
 321          -*---------------------------------------------------------------------------*/
 322          void uart0() interrupt 4
 323          {
 324   1         if(TI0)
 325   1         {
 326   2            TI0=0;
 327   2            if(gUart0Tx[gUart0NbrByteTx]!=0)
 328   2            {
 329   3               SBUF0=gUart0Tx[gUart0NbrByteTx];
 330   3               gUart0NbrByteTx++;
 331   3            }
 332   2            else
 333   2            {
 334   3               gUart0NbrByteTx=0;
 335   3            }
 336   2         }
 337   1         
 338   1         if(RI0)
 339   1         {
 340   2            RI0=0;
 341   2            gUart0Rx[gUart0NbrByteRx]=SBUF0;
 342   2            if(gUart0Rx[gUart0NbrByteRx]=='#')
 343   2             {
 344   3                gUart0FlagReceive=1;
 345   3             gUart0Rx[gUart0NbrByteRx+1]=0;
 346   3                gUart0NbrByteRx=0;
 347   3             }
 348   2             else
 349   2             {
 350   3                gUart0NbrByteRx=(gUart0NbrByteRx+1)%20;
 351   3             }
 352   2         }
 353   1      }
 354          
 355          /*---------------------------------------------------------------------------*-
 356          uart1()
 357          -----------------------------------------------------------------------------
 358          Descriptif: Fonction d'interruption de l'uart1 vecteur 16
 359          Entree    : --
 360          Sortie    : --
 361          -*---------------------------------------------------------------------------*/
 362          void uart1() interrupt 16
 363          {
 364   1         if(SCON1&0x02)//TI1
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 7   

 365   1         {
 366   2            SCON1=SCON1&~0x02;
 367   2            if(gUart1Tx[gUart1NbrByteTx]!=0)
 368   2            {
 369   3               SBUF1=gUart1Tx[gUart1NbrByteTx];
 370   3               gUart1NbrByteTx++;
 371   3            }
 372   2            else
 373   2            {
 374   3               gUart1NbrByteTx=0;
 375   3            }
 376   2         }
 377   1         
 378   1         if(SCON1&0x01)//RI1
 379   1         {
 380   2            SCON1=SCON1&~0x01;
 381   2            gUart1Rx[gUart1NbrByteRx]=SBUF1;
 382   2            if(gUart1Rx[gUart1NbrByteRx]=='\n')
 383   2             {
 384   3                gUart1FlagReceive=1;
 385   3             gUart1Rx[gUart1NbrByteRx+1]=0;
 386   3                gUart1NbrByteRx=0;
 387   3             }
 388   2             else
 389   2             {
 390   3                gUart1NbrByteRx=(gUart1NbrByteRx+1)%20;
 391   3             }
 392   2         }
 393   1      }
 394          
 395          //FONCTION
 396          
 397          /*---------------------------------------------------------------------------*-
 398          reset_i2c()
 399          -----------------------------------------------------------------------------
 400          Descriptif: Verifie si le bus I2C est bloquer, et effectue un reset du bus
 401          Entree    : --
 402          Sortie    : --
 403          -*---------------------------------------------------------------------------*/
 404          void reset_i2c()
 405          {
 406   1         unsigned char i=0;
 407   1        if(!SDA)
 408   1        {
 409   2          //Desactive tout l'I2C
 410   2          P0SKIP    = 0x03;//skip les pin SCL SDA
 411   2          XBR0      = 0x01;//desactive l'I2C
 412   2          //force le slave a sortir des donnee
 413   2          while(!SDA)
 414   2          {
 415   3            // Provide clock pulses to allow the slave to advance out
 416   3            // of its current state. This will allow it to release SDA.
 417   3            SCL = 0;                         // Drive the clock low
 418   3            for(i = 0; i < 100; i++);        // Hold the clock low
 419   3            SCL = 1;                         // Release the clock
 420   3            for(i = 0; i < 100; i++);        // Hold the clock low
 421   3          }
 422   2          P0SKIP   = 0x00;//Enleve les skip de pin SDA et SCL
 423   2          XBR0      = 0x05;//reactive l'i2c
 424   2        }
 425   1      }
 426          
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 8   

 427          /*---------------------------------------------------------------------------*-
 428          configMCP23008()
 429          -----------------------------------------------------------------------------
 430          Descriptif: 
 431          Entree    : unsigned char input (0 ... 255) - choix de pins a mettre en sortie
 432          Sortie    : --
 433          -*---------------------------------------------------------------------------*/
 434          void configMCP23008(unsigned char input)
 435          {
 436   1         gTarget = MCP23008_ADDR;       // gTarget the Slave for next SMBus transfer
 437   1         gSMBDataOUT[0]  = MCP23008_IODIR;
 438   1         gSMBDataOUT[1]  = input;       // Set as INPUT
 439   1         gSMBNumBytesToWR = 2;
 440   1         SMB_Write();  // Initiate SMBus write
 441   1      }
 442          
 443          /*---------------------------------------------------------------------------*-
 444          read_i2c_port()
 445          -----------------------------------------------------------------------------
 446          Descriptif: Lis le port du MCP23008
 447          Entree    : --
 448          Sortie    : unsigend char (0 ... 255)
 449          -*---------------------------------------------------------------------------*/
 450          unsigned char read_i2c_port()
 451          {
 452   1         while(SMB_BUSY);
 453   1         gTarget = MCP23008_ADDR;
 454   1         gSMBDataOUT[0]  = MCP23008_GPIO;
 455   1         gSMBNumBytesToWR = 1;
 456   1         SMB_Write();  // Initiate SMBus write
 457   1         while(SMB_BUSY);
 458   1         gTarget = MCP23008_ADDR;
 459   1         gSMBNumBytesToRD = 1;
 460   1         SMB_Read();  // Initiate SMBus write
 461   1         return gSMBDataIN[0];
 462   1      }
 463          
 464          /*---------------------------------------------------------------------------*-
 465          setMotorRA()
 466          -----------------------------------------------------------------------------
 467          Descriptif: Applique une vitesse predefinit au moteur et une direction
 468          Entree    : 
 469                      - unsigned char vitesse (0 ... 10)
 470                      - bit direction         (0 ... 1)
 471          Sortie    : --
 472          -*---------------------------------------------------------------------------*/
 473          void setMotorRA(unsigned char vitesse,bit direction)
 474          {
 475   1        unsigned int i=0;
 476   1        TR0=0;
 477   1         STEP_RA=0;
 478   1        //for(i=0;i<500;i++);//voire figure 1
 479   1         DIR_RA=direction;
 480   1        //for(i=0;i<;i++);//voire figure 1
 481   1         switch(vitesse)
 482   1         {
 483   2            case VITESSE_SIDERAL://suivi sideral
 484   2               gVitesseRAH=VITESSE_SIDERAL_HIGH;
 485   2               gVitesseRAL=VITESSE_SIDERAL_LOW;
 486   2            break;
 487   2            case VITESSE_LUNE://suivi Lune
 488   2               gVitesseRAH=VITESSE_LUNE_HIGH;
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 9   

 489   2               gVitesseRAL=VITESSE_LUNE_LOW;
 490   2            break;
 491   2            case VITESSE_SOLEIL://suivi Soleil-Planete generale
 492   2               gVitesseRAH=VITESSE_SOLEIL_HIGH;//
 493   2               gVitesseRAL=VITESSE_SOLEIL_LOW;
 494   2            break;
 495   2            case VITESSE_SATURNE://suivi Soleil-Planete generale
 496   2               gVitesseRAH=VITESSE_SATURNE_HIGH;//
 497   2               gVitesseRAL=VITESSE_SATURNE_LOW;
 498   2            break;
 499   2            case VITESSE_JUPITER://suivi Soleil-Planete generale
 500   2               gVitesseRAH=VITESSE_JUPITER_HIGH;//
 501   2               gVitesseRAL=VITESSE_JUPITER_LOW;
 502   2            break;
 503   2            case VITESSE_COMETE://suivi Soleil-Planete generale
 504   2               gVitesseRAH=VITESSE_COMETE_HIGH;//
 505   2               gVitesseRAL=VITESSE_COMETE_LOW;
 506   2            break;
 507   2            case VITESSE_ISS://suivi ISS
 508   2               gVitesseRAH=VITESSE_ISS_HIGH;
 509   2               gVitesseRAL=VITESSE_ISS_LOW;
 510   2            break;
 511   2            case VITESSE_X01://x0,1
 512   2               DIR_RA=0;
 513   2               if(direction==0)
 514   2               {
 515   3                  gVitesseRAH=VITESSE_X1_1_HIGH;
 516   3                  gVitesseRAL=VITESSE_X1_1_LOW;
 517   3               }
 518   2               else
 519   2               {
 520   3                  gVitesseRAH=VITESSE_X01_HIGH;
 521   3                  gVitesseRAL=VITESSE_X01_LOW;
 522   3               }
 523   2            break;
 524   2            case VITESSE_X02://x0,2
 525   2               DIR_RA=0;
 526   2               if(direction==0)
 527   2               {
 528   3                  gVitesseRAH=VITESSE_X1_2_HIGH;
 529   3                  gVitesseRAL=VITESSE_X1_2_LOW;
 530   3               }
 531   2               else
 532   2               {
 533   3                  gVitesseRAH=VITESSE_X02_HIGH;
 534   3                  gVitesseRAL=VITESSE_X02_LOW;
 535   3               }
 536   2            break;
 537   2            case VITESSE_X03://x0,3
 538   2               DIR_RA=0;
 539   2               if(direction==0)
 540   2               {
 541   3                  gVitesseRAH=VITESSE_X1_3_HIGH;
 542   3                  gVitesseRAL=VITESSE_X1_3_LOW;
 543   3               }
 544   2               else
 545   2               {
 546   3                  gVitesseRAH=VITESSE_X03_HIGH;
 547   3                  gVitesseRAL=VITESSE_X03_LOW;
 548   3               }
 549   2            break;
 550   2            case VITESSE_X04://x0,4
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 10  

 551   2               DIR_RA=0;
 552   2               if(direction==0)
 553   2               {
 554   3                  gVitesseRAH=VITESSE_X1_4_HIGH;
 555   3                  gVitesseRAL=VITESSE_X1_4_LOW;
 556   3               }
 557   2               else
 558   2               {
 559   3                  gVitesseRAH=VITESSE_X04_HIGH;
 560   3                  gVitesseRAL=VITESSE_X04_LOW;
 561   3               }
 562   2            break;
 563   2            case VITESSE_X05://x0,5
 564   2               DIR_RA=0;
 565   2               if(direction==0)
 566   2               {
 567   3                  gVitesseRAH=VITESSE_X1_5_HIGH;
 568   3                  gVitesseRAL=VITESSE_X1_5_LOW;
 569   3               }
 570   2               else
 571   2               {
 572   3                  gVitesseRAH=VITESSE_X05_HIGH;
 573   3                  gVitesseRAL=VITESSE_X05_LOW;
 574   3               }
 575   2            break;
 576   2            case VITESSE_X2://x2
 577   2               gVitesseRAH=VITESSE_X2_HIGH;
 578   2               gVitesseRAL=VITESSE_X2_LOW;
 579   2            break;
 580   2            case VITESSE_X8://x8
 581   2               gVitesseRAH=VITESSE_X8_HIGH;
 582   2               gVitesseRAL=VITESSE_X8_LOW;
 583   2            break;
 584   2            case VITESSE_X16://x16
 585   2               gVitesseRAH=VITESSE_X16_HIGH;
 586   2               gVitesseRAL=VITESSE_X16_LOW;
 587   2            break;
 588   2            case VITESSE_MAX://max
 589   2               gVitesseRAH=VITESSE_MAX_HIGH;
 590   2               gVitesseRAL=VITESSE_MAX_LOW;
 591   2            break;
 592   2            default://suivi sideral
 593   2               gVitesseRAH=VITESSE_SIDERAL_HIGH;
 594   2               gVitesseRAL=VITESSE_SIDERAL_LOW;      
 595   2            break;
 596   2         }
 597   1        TH0=gVitesseRAH ;//Charge la valeur dans le registre MSB du timer 0
 598   1         TL0=gVitesseRAL;//Charge la valeur dans le registre LSB du timer 0
 599   1         TR0=1;
 600   1      }
 601          
 602          /*---------------------------------------------------------------------------*-
 603          setMotorDEC()
 604          -----------------------------------------------------------------------------
 605          Descriptif: Applique une vitesse predefinit au moteur et une direction
 606          Entree    :
 607                      - unsigned char vitesse (6 ... 10)
 608                      - bit direction         (0 ... 1)
 609          Sortie    : --
 610          -*---------------------------------------------------------------------------*/
 611          void setMotorDEC(unsigned char vitesse,bit direction)
 612          {
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 11  

 613   1        unsigned int i=0;
 614   1        SFRPAGE   = CONFIG_PAGE;
 615   1         TMR4CN&=~0x04;
 616   1         SFRPAGE   = LEGACY_PAGE;
 617   1        //for(i=0;i<50000;i++);//voire figure 1
 618   1         NSLEEP_DEC=1;//Attention il faut 1.7ms au chip pour se rallumer
 619   1         STEP_DEC=0;
 620   1         DIR_DEC=direction;
 621   1        //for(i=0;i<50000;i++);//voire figure 1
 622   1         switch(vitesse)
 623   1         {
 624   2            case VITESSE_X01://x0,1
 625   2               gVitesseDECH=VITESSE_X01_HIGH;
 626   2               gVitesseDECL=VITESSE_X01_LOW;
 627   2               SFRPAGE   = CONFIG_PAGE;
 628   2               TMR4CN|=0x04;
 629   2               SFRPAGE   = LEGACY_PAGE;
 630   2            break;
 631   2            case VITESSE_X02://x0,2
 632   2               gVitesseDECH=VITESSE_X02_HIGH;
 633   2               gVitesseDECL=VITESSE_X02_LOW;
 634   2               SFRPAGE   = CONFIG_PAGE;
 635   2               TMR4CN|=0x04;
 636   2               SFRPAGE   = LEGACY_PAGE;
 637   2            break;
 638   2            case VITESSE_X03://x0,3
 639   2               gVitesseDECH=VITESSE_X03_HIGH;
 640   2               gVitesseDECL=VITESSE_X03_LOW;
 641   2               SFRPAGE   = CONFIG_PAGE;
 642   2               TMR4CN|=0x04;
 643   2               SFRPAGE   = LEGACY_PAGE;
 644   2            break;
 645   2            case VITESSE_X04://x0,4
 646   2               gVitesseDECH=VITESSE_X04_HIGH;
 647   2               gVitesseDECL=VITESSE_X04_LOW;
 648   2               SFRPAGE   = CONFIG_PAGE;
 649   2               TMR4CN|=0x04;
 650   2               SFRPAGE   = LEGACY_PAGE;
 651   2            break;
 652   2            case VITESSE_X05://x0,5
 653   2               gVitesseDECH=VITESSE_X05_HIGH;
 654   2               gVitesseDECL=VITESSE_X05_LOW;
 655   2               SFRPAGE   = CONFIG_PAGE;
 656   2               TMR4CN|=0x04;
 657   2               SFRPAGE   = LEGACY_PAGE;
 658   2            break;
 659   2            case VITESSE_X2://x2
 660   2               gVitesseDECH=VITESSE_X2_HIGH;
 661   2               gVitesseDECL=VITESSE_X2_LOW;
 662   2               SFRPAGE   = CONFIG_PAGE;
 663   2               TMR4CN|=0x04;
 664   2               SFRPAGE   = LEGACY_PAGE;
 665   2            break;
 666   2            case VITESSE_X8://x8
 667   2               gVitesseDECH=VITESSE_X8_HIGH;
 668   2               gVitesseDECL=VITESSE_X8_LOW;
 669   2               SFRPAGE   = CONFIG_PAGE;
 670   2               TMR4CN|=0x04;
 671   2               SFRPAGE   = LEGACY_PAGE;
 672   2            break;
 673   2            case VITESSE_X16://x16
 674   2               gVitesseDECH=VITESSE_X16_HIGH;
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 12  

 675   2               gVitesseDECL=VITESSE_X16_LOW;
 676   2               SFRPAGE   = CONFIG_PAGE;
 677   2               TMR4CN|=0x04;
 678   2               SFRPAGE   = LEGACY_PAGE;
 679   2            break;
 680   2            case VITESSE_MAX://max
 681   2               gVitesseDECH=VITESSE_MAX_HIGH;
 682   2               gVitesseDECL=VITESSE_MAX_LOW;
 683   2               SFRPAGE   = CONFIG_PAGE;
 684   2               TMR4CN|=0x04;
 685   2               SFRPAGE   = LEGACY_PAGE;
 686   2            break;
 687   2            default://suivi sideral
 688   2              stopMotorDec(); 
 689   2            break;
 690   2         }
 691   1      }
 692          
 693          /*---------------------------------------------------------------------------*-
 694          stopMotorDec()
 695          -----------------------------------------------------------------------------
 696          Descriptif: Stop le moteur de declinaison et met le drv8825 en sommeil
 697          Entree    : --
 698          Sortie    : --
 699          -*---------------------------------------------------------------------------*/
 700          void stopMotorDec()
 701          {
 702   1         SFRPAGE   = CONFIG_PAGE;
 703   1         TMR4CN&=~0x04;
 704   1         SFRPAGE   = LEGACY_PAGE;
 705   1         NSLEEP_DEC=0;
 706   1      }
 707          
 708          /*---------------------------------------------------------------------------*-
 709          decodeUartRaspberryPi()
 710          -----------------------------------------------------------------------------
 711          Descriptif: Decode les message envoyer par la raspberry PI
 712          Entree    : -- (Utilisation de varible globale)
 713          Sortie    : --
 714          -*---------------------------------------------------------------------------*/
 715          void decodeUartRaspberryPi()
 716          {
 717   1         if((gUart0Rx[0]=='R')&&(gUart0Rx[1]=='A'))
 718   1         {
 719   2            if((gUart0Rx[2]=='+'))
 720   2            {
 721   3               setMotorRA(gVitesseDeplacement,gDirRa);
 722   3            }
 723   2            else if (gUart0Rx[2]=='-')
 724   2            {
 725   3               setMotorRA(gVitesseDeplacement,!gDirRa);
 726   3            }
 727   2            else//=='0'
 728   2            {
 729   3               setMotorRA(gAstrSuivi,gDirRa);
 730   3            }
 731   2         }
 732   1         else if((gUart0Rx[0]=='D')&&(gUart0Rx[1]=='E')&&(gUart0Rx[2]=='C'))
 733   1         {
 734   2            if((gUart0Rx[3]=='+'))
 735   2            {
 736   3               setMotorDEC(gVitesseDeplacement,gDirDec);
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 13  

 737   3            }
 738   2            else if (gUart0Rx[3]=='-')
 739   2            {
 740   3               setMotorDEC(gVitesseDeplacement,!gDirDec);
 741   3            }
 742   2            else//=='0'
 743   2            {
 744   3               stopMotorDec();
 745   3            }
 746   2         }
 747   1        else//Ne reconnait pas la commande, fais suivre au slave
 748   1        {
 749   2          //gUart1Tx[0]
 750   2          strcpy(gUart1Tx,gUart0Rx);
 751   2          SCON1|=0x02;
 752   2        }
 753   1      }
 754          
 755          /*---------------------------------------------------------------------------*-
 756             UART_Init ()
 757            -----------------------------------------------------------------------------
 758             Descriptif: Configure l'UART par ces valeur par defaut
 759                         (il ne fait rien)
 760             Entr�e    : --
 761             Sortie    : --
 762          -*---------------------------------------------------------------------------*/
 763          void UART_Init()
 764          {
 765   1          SCON0     = 0x10;
 766   1          //SBRLL1    = 0x3C;
 767   1          //SBRLH1    = 0xF6;
 768   1          //SCON1     = 0x10;
 769   1          //SBCON1    = 0x43;
 770   1        
 771   1        //57600 Uart1
 772   1         SBRLL1    = 0x5F;
 773   1          SBRLH1    = 0xFE;
 774   1          SCON1     = 0x10;
 775   1          SBCON1    = 0x43;
 776   1        
 777   1        //115200 Uart1
 778   1      //  SBRLL1    = 0x30;
 779   1      //    SBRLH1    = 0xFF;
 780   1      //    SCON1     = 0x10;
 781   1      //    SBCON1    = 0x43;
 782   1      }
 783          
 784          /*---------------------------------------------------------------------------*-
 785          Init_int ()
 786          -----------------------------------------------------------------------------
 787          Descriptif:
 788          Interruption 0 : P0.6 - Descendant
 789          Interruption 1 : P0.7 - Descendant
 790          Entree    : --
 791          Sortie    : --
 792          -*---------------------------------------------------------------------------*/
 793          void Init_int()
 794          {
 795   1         EX0=0;//Autorise l'interruption externe 0
 796   1         EX1=0;//Autorise l'interruption externe 1
 797   1         IT0=1;//interruption 0 sur flanc
 798   1         IT1=1;//interruption 1 sur flanc
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 14  

 799   1         IT01CF= IT01CF &~ 0xFF;//Clear le registre des interruption
 800   1                               // +-------- INT1 Polarite
 801   1                               // |+++----- Selection du canal P0.x de l'interruption 1
 802   1                               // ||||+---- INT0 Polarite
 803   1                               // |||||+++- Selection du canal P0.x de l'interruption 0
 804   1                               // ||||||||  (000: Select P0.0)
 805   1                               // ||||||||  ...
 806   1                               // ||||||||  ...
 807   1                               // ||||||||  (111: Select P0.7)  
 808   1         IT01CF= IT01CF | 0x76;// 01110110
 809   1      
 810   1         IE0=0; IE0=0; IE0=0;//clear du flag d'interruption 0 (3* pour eviter les bug)
 811   1         IE1=0; IE1=0; IE1=0;//clear du flag d'interruption 1 (3* pour eviter les bug)
 812   1         EX0=1;//Active l'interruption 0
 813   1         EX1=1;//Active l'interruption 1
 814   1      }
 815          
 816          /*---------------------------------------------------------------------------*-
 817          TimerInit ()
 818          -----------------------------------------------------------------------------
 819          Descriptif:
 820          Timer 0 : Mode 16bit - Prediv 12 - vitesse definit par gVitesseRAH-L
 821          Timer 1 : Mode 8bit - Prediv 12 - baudrate A RECALCULER
 822          Entree    : --
 823          Sortie    : --
 824          -*---------------------------------------------------------------------------*/
 825          void TimerInit()
 826          {
 827   1         //Timer 0 et 1
 828   1         TR0 = 0;//Stop le timer 0
 829   1         TR1 = 0;
 830   1         ET0 = 0;//Desactive l'interruption du timer 0
 831   1         ET1=0;
 832   1         TMOD &= ~0x0F;//Clear le registre du mode 0
 833   1                      // +-------- Timer 1 Gate Control
 834   1                      // |+------- Counter/Timer1 Select
 835   1                      // ||++----- choix du mode du timer 1
 836   1                      // ||||+---- Timer 0 Gate Control
 837   1                      // |||||+--- Counter/Timer0 Select
 838   1                      // ||||||++- choix du mode du timer 0
 839   1                      // ||||||||  (00 : Mode 0, 13-bit Counter/Timer)
 840   1                      // ||||||||  (01 : Mode 1, 16-bit Counter/Timer)
 841   1                      // ||||||||  (10 : Mode 2, 8-bit Counter/Timer with reload
 842   1                      // ||||||||  (11 : Mode 3, Two 8-bit Counter/Timers)  
 843   1         TMOD |= 0x21;// 00000001
 844   1         CKCON &= ~0x07;//clear les bit de selection pour les timer 0 et 1 
 845   1                       // +-------- Timer 3 High Byte Clock Select.
 846   1                       // |+------- Timer 3 Low Byte Clock Select.
 847   1                       // ||+------ Timer 2 High Byte Clock Select
 848   1                       // |||+----- Timer 2 Low Byte Clock Select.
 849   1                       // ||||+---- Timer 1 Clock Select.
 850   1                       // |||||+--- Timer 0 Clock Select.
 851   1                       // ||||||++- Timer 0/1 Prescale Bits.
 852   1                       // ||||||||  (00: System clock divided by 12)
 853   1                       // ||||||||  (01: System clock divided by 4)
 854   1                       // ||||||||  (10: System clock divided by 48)
 855   1                       // ||||||||  (11: External clock divided by 8 
 856   1         CKCON |= 0x00;// 00000010
 857   1         TH0=gVitesseRAH;//Charge la valeur dans le registre MSB du timer 0
 858   1         TL0=gVitesseRAL;//Charge la valeur dans le registre LSB du timer 0
 859   1         TH1=TL1=BAUD_UART0;//Charge la valeur dans le registre LSB du timer 0
 860   1         TF0 = 0;//clear le flag d'interruption du timer 0
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 15  

 861   1         TF1 = 0;
 862   1         ET0 = 1;//Autorise l'interruption du timer 0
 863   1         //ET1 = 1;
 864   1         
 865   1         //Init Timer 4 
 866   1         SFRPAGE   = CONFIG_PAGE;
 867   1         TMR4CN = 0x00;//Mode 16 bit auto reload
 868   1         TMR4RLH=0xF7;
 869   1         TMR4RLL=0x8A;
 870   1         SFRPAGE   = LEGACY_PAGE;
 871   1      }
 872          
 873          /*---------------------------------------------------------------------------*-
 874             ClockInit ()
 875            -----------------------------------------------------------------------------
 876             Descriptif: Initialisation du mode de fonctionnement du clock syst�me 
 877                   choix : SYSCLK : oscillateur HF interne � 48 MHz
 878          
 879             Entr�e    : --
 880             Sortie    : --
 881          -*---------------------------------------------------------------------------*/
 882          void ClockInit()
 883          {  
 884   1         
 885   1                           // +--------- clock interne LF
 886   1                           // | (1 : oscillateur LF : enable)
 887   1                           // | (0 : oscillateur LF: desable)
 888   1                           // |+-------- en lecture seule 1 : signal que oscillateur 
 889   1                           // ||         interne fonctionne � sa valeur de prog.
 890   1                           // ||++++---- r�glage fin de la fr�quence de l'osc. LF
 891   1                           // ||||||++-- choix du diviseur :
 892   1                           // ||||||||       (00 : Osc LF /8 -> f = 10 KHz)
 893   1                           // ||||||||       (01 : Osc LF /4 -> f = 20 KHz)
 894   1                           // ||||||||       (10 : Osc LF /2 -> f = 40 KHz)
 895   1                           // ||||||||       (11 : Osc LF /1 -> f = 80 KHz)
 896   1         OSCLCN |= 0x00;   // 00000000 
 897   1      
 898   1                           // +--------- non utilis�
 899   1                           // |+++------ S�lection du clock USB 
 900   1                           // ||||           (010 : Oscil ext. : limiter la conso.)
 901   1                           // ||||+----- clock out select
 902   1                           // |||||          (0 : sortie sysclk non synchronis�e)
 903   1                           // |||||          (1 : sortie sysclk synchronis�e)
 904   1                           // |||||+++-- choix du clock syst�me
 905   1                           // ||||||||       (000 : Oscil interne 48/4  = 1.5, 3, 6 ou
 906   1                           // ||||||||              12 MHz selon le choix du diviseur 
 907   1                           // ||||||||              dans OSCICN
 908   1                           // ||||||||       (001 : Oscil externe  = x  MHz)
 909   1                           // ||||||||       (010 : Oscil interne 48/2 = 24 MHz)
 910   1                           // ||||||||       (011 : Oscil interne 48/1 = 48 MHz)    
 911   1                           // ||||||||       (100 : Oscil interne LF = 80 KHz max)   
 912   1                           // ||||||||       (101 � 111 : r�serv�s)   
 913   1         CLKSEL = 0x03;    // 00000011  
 914   1      
 915   1                           // +--------- clock interne HF
 916   1                           // |              (1 : oscillateur LF : enable)
 917   1                           // |              (0 : oscillateur LF: desable)
 918   1                           // |+-------- en lecture seule 1 : signal que oscillateur 
 919   1                           // ||              interne fonctionne � sa valeur de prog.
 920   1                           // ||+------- 1 : suspend l'oscillateur interne
 921   1                           // |||+++---- non utilis�s
 922   1                           // ||||||++-- choix du diviseur :
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 16  

 923   1                           // ||||||||       (00 : 12/8 -> f =  1.5 MHz)
 924   1                           // ||||||||       (01 : 12/4 -> f =  3   MHz)
 925   1                           // ||||||||       (10 : 12/2 -> f =  6   MHz)
 926   1                           // ||||||||       (11 : 12/1 -> f = 12   MHz)
 927   1         OSCICN = 0xC3;    // 11000011 
 928   1         
 929   1         FLSCL = 0x90;     // A utiliser si le clock system est � 48 MHz
 930   1      
 931   1      } // ClockInit ----------------------------------------------------------------
 932          
 933          
 934          //-----------------------------------------------------------------------------
 935          // SMBus_Init
 936          //-----------------------------------------------------------------------------
 937          //
 938          // Return Value : None
 939          // Parameters   : None
 940          //
 941          // SMBus configured as follows:
 942          // - SMBus enabled
 943          // - Slave mode inhibited
 944          // - Timer2 used as clock source. The maximum SCL frequency will be
 945          //   approximately 1/3 the Timer1 overflow rate
 946          // - Setup and hold time extensions enabled
 947          // - Bus Free and SCL Low timeout detection enabled
 948          //
 949          void SMBus_Init (void)
 950          {
 951   1         SMB0CF = 0x5E;                      // Use Timer2 overflows as SMBus clock
 952   1                                             // source;
 953   1                                             // Disable slave mode;
 954   1                                             // Enable setup & hold time
 955   1                                             // extensions;
 956   1                                             // Enable SMBus Free timeout detect;
 957   1                                             // Enable SCL low timeout detect;
 958   1      
 959   1         SMB0CF |= 0x80;                     // Enable SMBus;
 960   1      }
 961          
 962          
 963          //-----------------------------------------------------------------------------
 964          // Timer2_Init
 965          //-----------------------------------------------------------------------------
 966          //
 967          // Return Value : None
 968          // Parameters   : None
 969          //
 970          // Timer2 configured as the SMBus clock source as follows:
 971          // - Timer2 in 8-bit auto-reload mode
 972          // - SYSCLK or SYSCLK / 4 as Timer1 clock source
 973          // - Timer2 overflow rate => 3 * SMB_FREQUENCY
 974          // - The resulting SCL clock rate will be ~1/3 the Timer2 overflow rate
 975          // - Timer2 enabled
 976          //
 977          void Timer2_Init (void)
 978          {
 979   1         TMR2CN    |= 0x0C;//0x0C
 980   1         TMR2RLH   |= 0x7B;//0x7B
 981   1      }
 982          
 983          //-----------------------------------------------------------------------------
 984          // Timer3_Init
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 17  

 985          //-----------------------------------------------------------------------------
 986          //
 987          // Return Value : None
 988          // Parameters   : None
 989          //
 990          // Timer3 configured for use by the SMBus low timeout detect feature as
 991          // follows:
 992          // - Timer3 in 16-bit auto-reload mode
 993          // - SYSCLK/12 as Timer3 clock source
 994          // - Timer3 reload registers loaded for a 25ms overflow period
 995          // - Timer3 pre-loaded to overflow after 25ms
 996          // - Timer3 enabled
 997          //
 998          void Timer3_Init (void)
 999          {
1000   1         TMR3CN = 0x00;                      // Timer3 configured for 16-bit auto-
1001   1                                             // reload, low-byte interrupt disabled
1002   1      
1003   1         CKCON &= ~0x40;                     // Timer3 uses SYSCLK/12
1004   1      
1005   1         TMR3RL = -(SYSCLK/12/40);           // Timer3 configured to overflow after
1006   1         TMR3 = TMR3RL;                      // ~25ms (for SMBus low timeout detect):
1007   1                                             // 1/.025 = 40
1008   1      
1009   1         EIE1 |= 0x80;                       // Timer3 interrupt enable
1010   1         TMR3CN |= 0x04;                     // Start Timer3
1011   1      }
1012          
1013          //-----------------------------------------------------------------------------
1014          // SMBus Interrupt Service Routine (ISR)
1015          //-----------------------------------------------------------------------------
1016          //
1017          // SMBus ISR state machine
1018          // - Master only implementation - no slave or arbitration states defined
1019          // - All incoming data is written to global variable array <gSMBDataIN>
1020          // - All outgoing data is read from global variable array <gSMBDataOUT>
1021          //
1022          void SMBus_ISR (void) interrupt 7
1023          {
1024   1         bit FAIL = 0;                       // Used by the ISR to flag failed
1025   1                                             // transfers
1026   1      
1027   1         static unsigned char sent_byte_counter;
1028   1         static unsigned char rec_byte_counter;
1029   1      
1030   1         if (ARBLOST0 == 0)                   // Check for errors
1031   1         {
1032   2            // Normal operation
1033   2            switch (SMB0CN & 0xF0)           // Status vector
1034   2            {
1035   3               // Master Transmitter/Receiver: START condition transmitted.
1036   3               case SMB_MTSTA:
1037   3                  SMB0DAT = gTarget;          // Load address of the gTarget slave
1038   3                  SMB0DAT &= 0xFE;           // Clear the LSB of the address for the
1039   3                                             // R/W bit
1040   3                  SMB0DAT |= SMB_RW;         // Load R/W bit
1041   3                  STA0 = 0;                   // Manually clear START bit
1042   3                  rec_byte_counter = 1;      // Reset the counter
1043   3                  sent_byte_counter = 1;     // Reset the counter
1044   3                  break;
1045   3      
1046   3               // Master Transmitter: Data byte transmitted
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 18  

1047   3               case SMB_MTDB:
1048   3                  if (ACK0)                   // Slave ACK0?
1049   3                  {
1050   4                     if (SMB_RW == WRITE)    // If this transfer is a WRITE,
1051   4                     {
1052   5                        if (sent_byte_counter <= gSMBNumBytesToWR)
1053   5                        {
1054   6                           // send data byte
1055   6                           SMB0DAT = gSMBDataOUT[sent_byte_counter-1];
1056   6                           sent_byte_counter++;
1057   6                        }
1058   5                        else
1059   5                        {
1060   6                           STO0 = 1;          // Set STO0 to terminate transfer
1061   6                           SMB_BUSY = 0;     // And free SMBus interface
1062   6                        }
1063   5                     }
1064   4                     else {}                 // If this transfer is a READ,
1065   4                                             // proceed with transfer without
1066   4                                             // writing to SMB0DAT (switch
1067   4                                             // to receive mode)
1068   4      
1069   4      
1070   4                  }
1071   3                  else                       // If slave NACK,
1072   3                  {
1073   4                     STO0 = 1;                // Send STOP condition, followed
1074   4                     STA0 = 1;                // By a START
1075   4                     NUM_ERRORS++;           // Indicate error
1076   4                  }
1077   3                  break;
1078   3      
1079   3               // Master Receiver: byte received
1080   3               case SMB_MRDB:
1081   3                  if (rec_byte_counter < gSMBNumBytesToRD)
1082   3                  {
1083   4                     gSMBDataIN[rec_byte_counter-1] = SMB0DAT; // Store received
1084   4                                                                // byte
1085   4                     ACK0 = 1;                // Send ACK0 to indicate byte received
1086   4                     rec_byte_counter++;     // Increment the byte counter
1087   4                  }
1088   3                  else
1089   3                  {
1090   4                     gSMBDataIN[rec_byte_counter-1] = SMB0DAT; // Store received
1091   4                                                                // byte
1092   4                     SMB_BUSY = 0;           // Free SMBus interface
1093   4                     ACK0 = 0;                // Send NACK to indicate last byte
1094   4                                             // of this transfer
1095   4      
1096   4                     STO0 = 1;                // Send STOP to terminate transfer
1097   4                  }
1098   3                  break;
1099   3      
1100   3               default:
1101   3                  FAIL = 1;                  // Indicate failed transfer
1102   3                                             // and handle at end of ISR
1103   3                  break;
1104   3      
1105   3            } // end switch
1106   2         }
1107   1         else
1108   1         {
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 19  

1109   2            // ARBLOST = 1, error occurred... abort transmission
1110   2            FAIL = 1;
1111   2         } // end ARBLOST if
1112   1      
1113   1         if (FAIL)                           // If the transfer failed,
1114   1         {
1115   2            SMB0CF &= ~0x80;                 // Reset communication
1116   2            SMB0CF |= 0x80;
1117   2            STA0 = 0;
1118   2            STO0 = 0;
1119   2            ACK0 = 0;
1120   2      
1121   2            SMB_BUSY = 0;                    // Free SMBus
1122   2      
1123   2            FAIL = 0;
1124   2            //LED = 0;
1125   2      
1126   2            NUM_ERRORS++;                    // Indicate an error occurred
1127   2         }
1128   1      
1129   1         SI0 = 0;                             // Clear interrupt flag
1130   1      }
1131          
1132          //-----------------------------------------------------------------------------
1133          // Timer3 Interrupt Service Routine (ISR)
1134          //-----------------------------------------------------------------------------
1135          //
1136          // A Timer3 interrupt indicates an SMBus SCL low timeout.
1137          // The SMBus is disabled and re-enabled here
1138          //
1139          void Timer3_ISR (void) interrupt 14
1140          {
1141   1         SMB0CF &= ~0x80;                    // Disable SMBus
1142   1         SMB0CF |= 0x80;                     // Re-enable SMBus
1143   1         TMR3CN &= ~0x80;                    // Clear Timer3 interrupt-pending
1144   1                                             // flag
1145   1         STA0 = 0;
1146   1         SMB_BUSY = 0;                       // Free SMBus
1147   1      }
1148          
1149          //-----------------------------------------------------------------------------
1150          // Support Functions
1151          //-----------------------------------------------------------------------------
1152          
1153          //-----------------------------------------------------------------------------
1154          // SMB_Write
1155          //-----------------------------------------------------------------------------
1156          //
1157          // Return Value : None
1158          // Parameters   : None
1159          //
1160          // Writes a single byte to the slave with address specified by the <gTarget>
1161          // variable.
1162          // Calling sequence:
1163          // 1) Write gTarget slave address to the <gTarget> variable
1164          // 2) Write outgoing data to the <gSMBDataOUT> variable array
1165          // 3) Call SMB_Write()
1166          //
1167          void SMB_Write (void)
1168          {
1169   1         while (SMB_BUSY);                   // Wait for SMBus to be free.
1170   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 20  

1171   1         SMB_RW = 0;                         // Mark this transfer as a WRITE
1172   1         STA0 = 1;                            // Start transfer
1173   1      }
1174          
1175          //-----------------------------------------------------------------------------
1176          // SMB_Read
1177          //-----------------------------------------------------------------------------
1178          //
1179          // Return Value : None
1180          // Parameters   : None
1181          //
1182          // Reads a single byte from the slave with address specified by the <gTarget>
1183          // variable.
1184          // Calling sequence:
1185          // 1) Write gTarget slave address to the <gTarget> variable
1186          // 2) Call SMB_Write()
1187          // 3) Read input data from <gSMBDataIN> variable array
1188          //
1189          void SMB_Read (void)
1190          {
1191   1         while (SMB_BUSY);                   // Wait for bus to be free.
1192   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
1193   1         SMB_RW = 1;                         // Mark this transfer as a READ
1194   1      
1195   1         STA0 = 1;                            // Start transfer
1196   1      
1197   1         while (SMB_BUSY);                   // Wait for transfer to complete
1198   1      }
1199          
1200          
1201          /*---------------------------------------------------------------------------*-
1202             PortInit ()
1203            -----------------------------------------------------------------------------
1204             Descriptif: autorise le fonctionnement du crossbar et de l'uart0
1205             Entr�e    : --
1206             Sortie    : --
1207          -*---------------------------------------------------------------------------*/
1208          void PortInit () 
1209          {
1210   1         // P0.0  -  SDA (SMBus0), Open-Drain, Digital
1211   1          // P0.1  -  SCL (SMBus0), Push-Pull,  Digital
1212   1          // P0.2  -  TX1 (UART1), Push-Pull,  Digital
1213   1          // P0.3  -  RX1 (UART1), Open-Drain, Digital
1214   1          // P0.4  -  TX0 (UART0), Push-Pull,  Digital
1215   1          // P0.5  -  RX0 (UART0), Open-Drain, Digital
1216   1          // P0.6  -  Unassigned,  Open-Drain, Digital
1217   1          // P0.7  -  Unassigned,  Open-Drain, Digital
1218   1      
1219   1          // P1.0  -  Skipped,     Push-Pull,  Digital
1220   1          // P1.1  -  Skipped,     Push-Pull,  Digital
1221   1          // P1.2  -  Skipped,     Push-Pull,  Digital
1222   1          // P1.3  -  Skipped,     Open-Drain, Digital
1223   1          // P1.4  -  Skipped,     Push-Pull,  Digital
1224   1          // P1.5  -  Skipped,     Push-Pull,  Digital
1225   1          // P1.6  -  Skipped,     Push-Pull,  Digital
1226   1          // P1.7  -  Skipped,     Open-Drain, Digital
1227   1      
1228   1          // P2.0  -  Skipped,     Open-Drain, Digital
1229   1          // P2.1  -  Skipped,     Open-Drain, Digital
1230   1          // P2.2  -  Skipped,     Open-Drain, Digital
1231   1          // P2.3  -  Skipped,     Open-Drain, Digital
1232   1          // P2.4  -  Unassigned,  Open-Drain, Digital
C51 COMPILER V9.60.0.0   MASTER_TELESCOPE_V3                                               07/09/2020 14:40:23 PAGE 21  

1233   1          // P2.5  -  Unassigned,  Open-Drain, Digital
1234   1          // P2.6  -  Unassigned,  Open-Drain, Digital
1235   1          // P2.7  -  Unassigned,  Open-Drain, Digital
1236   1      
1237   1          // P3.0  -  Unassigned,  Open-Drain, Digital
1238   1      
1239   1          P0MDOUT   = 0x16;
1240   1          P1MDOUT   = 0xDD;//0xFF = schema
1241   1          P1SKIP    = 0xFF;
1242   1          P2SKIP    = 0x0F;
1243   1          XBR0      |= 0x05;
1244   1          XBR1      |= 0x40;
1245   1          XBR2      |= 0x01;
1246   1      
1247   1      } // PortInit ----------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2241    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     40    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     39    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     11    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE SLAVE_TELESCOPE
OBJECT MODULE PLACED IN .\Objects\Slave_Telescope.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Slave_Telescope.c OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\Slave_Telescope.lst) TABS(3) OBJECT(.\Objects\Slave_Telescope.obj)

line level    source

   1          /*===========================================================================*=
   2             Slave_telescope - Tanguy Dietrich
   3            =============================================================================
   4             Descriptif: Permet de reguler la temperature des miroir ou des lentille
   5                         d'un telescope en utilisant la temperature du point de rose
   6                         ou des potentiometre
   7             
   8          =*===========================================================================*/
   9          
  10          #include <reg51f380.h>     // registres 51f38C
  11          #include "SmBus0.h"
  12          #include "PID.h"
  13          #include "Delay48M.h"
  14          #include "math.h"
  15          
  16          #define LOADVALUE_T0 15536
  17          #define LOADVALUE_BAUD 247
  18          
  19          // ==== FONCTIONS PROTOTYPES===================================================
  20          void ClockInit ();         // init. clock syst�me
  21          void PortInit ();          // init. config des ports
  22          void SMBus_Init (void);
  23          void Timer3_Init (void);
  24          void Timer2_Init (void);
  25          void Uart0Init();
  26          void SMB_Write (void);
  27          void SMB_Read (void);
  28          void PCA_Init();
  29          void decodeUart0();
  30          void TimerInit();
  31          void ADCInit();
  32          void configEeh210(unsigned char mode);
  33          long convertToTemp_i2c(unsigned int value);
  34          unsigned int convertToHumi(unsigned int value);
  35          long getTempAmbiante();
  36          unsigned int GetHumidite();
  37          void actu_Pca0_Pid(int tempCapt,int consigne);
  38          void actu_Pca1_Pid(int tempCapt,int consigne);
  39          void actu_Pca2_Pid(int tempCapt,int consigne);
  40          void actu_Pca3_Pid(int tempCapt,int consigne);
  41          int convertLm35ToTemp(unsigned int adc_pos,unsigned int adc_neg);
  42          void reset_i2c();
  43          int calculRose(float t_ambiante, float humidite);
  44          unsigned char ConvertToPca(unsigned int adc);
  45          void ActuAvgMesure(unsigned int tabMesure[12][NMESURE], unsigned int tabSortie[]);
  46          sbit SDA = P0^6;
  47          sbit SCL= P0^7;
  48          // ==== MAIN ==================================================================
  49          
  50          //SMBus0
  51          unsigned char gSMBNumBytesToWR = 2; // Number of bytes to write
  52                                              // Master -> Slave
  53          unsigned char gSMBNumBytesToRD = 3; // Number of bytes to read
  54                                              // Master <- Slave
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 2   

  55          
  56          // Global holder for SMBus data
  57          // All receive data is written here
  58          xdata unsigned char gSMBDataIN[NUM_BYTES_MAX_RD];
  59          
  60          // Global holder for SMBus data.
  61          // All transmit data is read from here
  62          xdata unsigned char gSMBDataOUT[NUM_BYTES_MAX_WR];
  63          
  64          unsigned char gTarget;                  // gTarget SMBus slave address
  65          
  66          bit SMB_BUSY;                          // Software flag to indicate when the
  67                                                 // SMB_Read() or SMB_Write() functions
  68                                                 // have claimed the SMBus
  69          
  70          bit SMB_RW;                            // Software flag to indicate the
  71                                                 // direction of the current transfer
  72          
  73          xdata unsigned long NUM_ERRORS;              // Counter for the number of errors.
  74          
  75          
  76          
  77          //Uart
  78          xdata unsigned char gUart0Tx[15]="";
  79          xdata unsigned char gUart0Rx[15];
  80          unsigned char gUart0NbrByteTx=0;
  81          unsigned char gUart0NbrByteRx=0;
  82          bit gUart0FlagReceive;
  83          
  84          //Mesure ADC
  85          xdata unsigned int gMesure[12][NMESURE];
  86          xdata unsigned int gMesureAvg[12];
  87          bit gFlagMesureAvg=0;
  88          
  89          bit gFlagActuI2c=0;
  90          long gTempAmbiante=0;
  91          unsigned int gHumidite=0;
  92          unsigned char gModeRegulation=MODE_UART;
  93          bit gFlagPot=0;
  94          void main () 
  95          {
  96   1         //unsigned char i=0;
  97   1         //unsigned char temp_pwm=0;
  98   1         int tempSensor;
  99   1         int temp_rose=0;
 100   1         PCA0MD &= ~0x40;     // WDTE = 0 (disable watchdog timer)
 101   1         ClockInit ();        // init. clock syst�me
 102   1         PortInit ();         // init. config des ports
 103   1         Timer3_Init();                      // Configure Timer3 for use with SMBus
 104   1                                             // low timeout detect
 105   1         Timer2_Init();
 106   1         SMBus_Init ();                      // Configure and enable SMBus
 107   1         PCA_Init();
 108   1         TimerInit();
 109   1         Uart0Init();
 110   1         ADCInit();
 111   1         
 112   1         EA=1;//Autorise toutes les interruption
 113   1         IE|=0x90;
 114   1         EIE1 |= 0x09;
 115   1         TR1=1;
 116   1         TR0=1;
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 3   

 117   1         SDA=1;
 118   1         reset_i2c();
 119   1         configEeh210(0);
 120   1         gHumidite=GetHumidite();
 121   1         gTempAmbiante=getTempAmbiante();
 122   1         while (1)
 123   1         {
 124   2            gModeRegulation=P0&0x07;
 125   2            if(gUart0FlagReceive)
 126   2            {
 127   3               gUart0FlagReceive=0;
 128   3               decodeUart0();
 129   3            }
 130   2            
 131   2            if(gFlagMesureAvg)
 132   2            {
 133   3               gFlagMesureAvg=0;
 134   3               ActuAvgMesure(gMesure,gMesureAvg);
 135   3               if(gModeRegulation==MODE_PID)
 136   3               {
 137   4                  tempSensor=convertLm35ToTemp(gMesureAvg[LM35_0_POS],gMesureAvg[LM35_0_NEG]);
 138   4                  actu_Pca0_Pid(tempSensor,temp_rose);
 139   4                  
 140   4                  tempSensor=convertLm35ToTemp(gMesureAvg[LM35_1_POS],gMesureAvg[LM35_1_NEG]);
 141   4                  actu_Pca1_Pid(tempSensor,temp_rose);
 142   4                  
 143   4                  tempSensor=convertLm35ToTemp(gMesureAvg[LM35_2_POS],gMesureAvg[LM35_2_NEG]);
 144   4                  actu_Pca2_Pid(tempSensor,temp_rose);
 145   4                  
 146   4                  tempSensor=convertLm35ToTemp(gMesureAvg[LM35_3_POS],gMesureAvg[LM35_3_NEG]);
 147   4                  actu_Pca3_Pid(tempSensor,temp_rose);
 148   4               }
 149   3            }
 150   2            
 151   2            if(gFlagPot)
 152   2            {
 153   3               gFlagPot=0;
 154   3               if(gModeRegulation==MODE_POT)
 155   3               {
 156   4                  PCA0CPH0=ConvertToPca(gMesure[POT_0][0]);
 157   4                  PCA0CPH1=ConvertToPca(gMesure[POT_1][0]);
 158   4                  PCA0CPH2=ConvertToPca(gMesure[POT_2][0]);
 159   4                  PCA0CPH3=ConvertToPca(gMesure[POT_3][0]);
 160   4               }
 161   3            }
 162   2            
 163   2            if(gFlagActuI2c)
 164   2            {
 165   3               gHumidite=GetHumidite();
 166   3               gTempAmbiante=getTempAmbiante();
 167   3               temp_rose=calculRose(gTempAmbiante, gHumidite);
 168   3               temp_rose+=CORRECTION_TEMPERATURE;
 169   3               //temp_rose=DEMO_CONSIGNE;
 170   3               gFlagActuI2c=0;
 171   3               //temp_rose=calculRose(300, 60);
 172   3            }
 173   2         } // End while (1)
 174   1      } // main =====================================================================
 175          
 176          /*---------------------------------------------------------------------------*-
 177          timer0()
 178          -----------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 4   

 179          Descriptif: Fonction d'interruption Timer0 vecteur 1
 180                    Temporisation de 50milli
 181                    Mode : 16bit
 182          Entree    : --
 183          Sortie    : --
 184          -*---------------------------------------------------------------------------*/
 185          void timer0() interrupt 1
 186          {
 187   1         static unsigned char cpt_i2c=0;
 188   1         static unsigned char cpt_adc=0;
 189   1         TR0=0;
 190   1         TH0=LOADVALUE_T0/256;//Charge la valeur dans le registre MSB du timer 0
 191   1         TL0=LOADVALUE_T0%256;//Charge la valeur dans le registre LSB du timer 0
 192   1         //TR0=1;
 193   1         if(cpt_adc>=DELAI_MESURE)
 194   1         {
 195   2            cpt_adc=0;
 196   2            AD0BUSY=1;
 197   2         }
 198   1         cpt_adc++;
 199   1         if(cpt_i2c>=20)
 200   1         {
 201   2            cpt_i2c=0;
 202   2            gFlagActuI2c=1;
 203   2         }
 204   1         cpt_i2c++;
 205   1         TR0=1;
 206   1      }
 207          
 208          /*---------------------------------------------------------------------------*-
 209          ADCComplete()
 210          -----------------------------------------------------------------------------
 211          Descriptif: fonction d'interruption de fin de conversion de l'ADC vecteur 10
 212          Pin + : P1.1
 213          Pin - : GND
 214          Aligner a Droite
 215          Conversion sur : AD0BUSY=1;
 216          Clock SAR : 2000000
 217          Entree    : --
 218          Sortie    : --
 219          -*---------------------------------------------------------------------------*/
 220          void ADCComplete() interrupt 10
 221          {
 222   1         unsigned char i=0;
 223   1         static unsigned char cptMesure=0;
 224   1         gMesure[AMX0P][cptMesure]=ADC0L+(ADC0H<<8);
 225   1         if(AMX0P<=0x0A)
 226   1         {
 227   2            AMX0P++;//change le canal de l'ADC a P2.3
 228   2            for(i=0;i<25;i++)//Attend que les condensateur se decharge
 229   2            {
 230   3               
 231   3            }
 232   2            AD0BUSY=1;//lance une conversion
 233   2         }
 234   1         else
 235   1         {
 236   2            AMX0P=0x00;//remet le canal P2.0
 237   2            //MovingAvg(gMesure,gAvgMesure);
 238   2            cptMesure++;
 239   2            gFlagPot=1;
 240   2            if(cptMesure==NMESURE)
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 5   

 241   2            {
 242   3               gFlagMesureAvg=1;//Mets le flag a 1 pour signifier au main d'actualiser
 243   3               cptMesure=0;
 244   3            }
 245   2         }
 246   1         AD0INT=0;
 247   1      }
 248          
 249          /*---------------------------------------------------------------------------*-
 250          uart0()
 251          -----------------------------------------------------------------------------
 252          Descriptif: Fonction d'interruption de l'uart0 vecteur 4
 253          Entree    : --
 254          Sortie    : --
 255          -*---------------------------------------------------------------------------*/
 256          void uart0() interrupt 4
 257          {
 258   1         if(TI0)
 259   1         {
 260   2            TI0=0;
 261   2            if(gUart0Tx[gUart0NbrByteTx]!=0)
 262   2            {
 263   3               SBUF0=gUart0Tx[gUart0NbrByteTx];
 264   3               gUart0NbrByteTx++;
 265   3            }
 266   2            else
 267   2            {
 268   3               gUart0NbrByteTx=0;
 269   3            }
 270   2         }
 271   1         
 272   1         if(RI0)
 273   1         {
 274   2            RI0=0;
 275   2            gUart0Rx[gUart0NbrByteRx]=SBUF0;
 276   2            if(gUart0Rx[gUart0NbrByteRx]=='#')
 277   2             {
 278   3                gUart0FlagReceive=1;
 279   3                gUart0NbrByteRx=0;
 280   3             }
 281   2             else
 282   2             {
 283   3                gUart0NbrByteRx=(gUart0NbrByteRx+1)%20;
 284   3             }
 285   2         }
 286   1      }
 287          
 288          /*---------------------------------------------------------------------------*-
 289             ActuAvgMesure ()
 290            -----------------------------------------------------------------------------
 291             Descriptif: Calcul la moyenne de mesure effectuer par l'ADC
 292             Entrée    : 
 293                         - unsigned int tabMesure[12][NMESURE] - tableau de mesure
 294                         - unsigend int tabSortie[] - tableau de sortie pour les moyenne
 295             Sortie    : --
 296          -*---------------------------------------------------------------------------*/
 297          void ActuAvgMesure(unsigned int tabMesure[12][NMESURE], unsigned int tabSortie[])
 298          {
 299   1         unsigned char canal=0;
 300   1         unsigned char nMesure=0;
 301   1         unsigned long somme;
 302   1         for(canal=0;canal<12;canal++)
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 6   

 303   1         {
 304   2            somme=0;
 305   2            for(nMesure=0;nMesure<NMESURE;nMesure++)
 306   2            {
 307   3               somme+=tabMesure[canal][nMesure];
 308   3            }
 309   2            tabSortie[canal]=somme/NMESURE;
 310   2         }
 311   1      }
 312          
 313          /*---------------------------------------------------------------------------*-
 314             ConvertToPca ()
 315            -----------------------------------------------------------------------------
 316             Descriptif: Convertie une valeur entre 0 et 1023, de 0 a 255
 317             Entrée    : unsigend int adc (0 ... 1023)
 318             Sortie    : unsigend char (0 ... 255)
 319          -*---------------------------------------------------------------------------*/
 320          unsigned char ConvertToPca(unsigned int adc)
 321          {
 322   1         return 255-((unsigned long)adc*255)/1023;
 323   1      }
 324          
 325          /*---------------------------------------------------------------------------*-
 326             calculRose ()
 327            -----------------------------------------------------------------------------
 328             Descriptif: 
 329             Entrée    : 
 330                         - float t_ambiante
 331                         - float humidite
 332             Sortie    : int (-32767 ... +32767) la temperature du point de rosé
 333                         Ex : -2767 --> -27.67[C]
 334          -*---------------------------------------------------------------------------*/
 335          int calculRose(float t_ambiante, float humidite)
 336          {
 337   1         float tRose=0;
 338   1         tRose=pow(((float)humidite/100),0.125);
 339   1         tRose=tRose*(112+(9*t_ambiante)/1000);
 340   1         tRose+=((t_ambiante)/1000)-112;
 341   1         return tRose*10;
 342   1      }
 343          
 344          /*---------------------------------------------------------------------------*-
 345             convertLm35ToTemp ()
 346            -----------------------------------------------------------------------------
 347             Descriptif: 
 348             Entrée    : --
 349             Sortie    : --
 350          -*---------------------------------------------------------------------------*/
 351          int convertLm35ToTemp(unsigned int adc_pos,unsigned int adc_neg)
 352          {
 353   1         int temp=0;
 354   1         temp=adc_pos-adc_neg;
 355   1         temp=((long)temp*REF_ADC)/100;
 356   1         return temp;
 357   1      }
 358          
 359          /*---------------------------------------------------------------------------*-
 360             actu_Pca0_Pid ()
 361            -----------------------------------------------------------------------------
 362             Descriptif: calul le pwm a appliquer sur la resistance en fonction du PID
 363             Entrée    : 
 364                         - int tempCapt
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 7   

 365                         - int consigne
 366             Sortie    : --
 367          -*---------------------------------------------------------------------------*/
 368          void actu_Pca0_Pid(int tempCapt,int consigne)
 369          {
 370   1         static int pwm1=0;
 371   1         static unsigned char old_error=0;
 372   1         int error=0;
 373   1         if(tempCapt<consigne)
 374   1         {
 375   2            error=consigne-tempCapt;
 376   2            pwm1=255-((int)error*KP)+((old_error-error)*KD);
 377   2            //pwm1=0;//mode tout ou rien
 378   2         }
 379   1         else
 380   1         {
 381   2            pwm1=255;//0%
 382   2            error=0;
 383   2         }
 384   1         old_error=error;
 385   1         if(pwm1<=0)
 386   1         {
 387   2            PCA0CPM0|=0x40;//reactive le pca0 si il a ete desactiver
 388   2            PCA0CPH0=0;
 389   2         }
 390   1         else if(pwm1>=255)
 391   1         {
 392   2            PCA0CPH0=255;
 393   2            PCA0CPM0&=~0x40;//Clear ecom0 afin d'obtenir 0%
 394   2         }
 395   1         else
 396   1         {
 397   2            PCA0CPH0=pwm1;
 398   2         }
 399   1      }
 400          
 401          /*---------------------------------------------------------------------------*-
 402             actu_Pca1_Pid ()
 403            -----------------------------------------------------------------------------
 404             Descriptif: calul le pwm a appliquer sur la resistance en fonction du PID
 405             Entrée    : 
 406                         - int tempCapt
 407                         - int consigne
 408             Sortie    : --
 409          -*---------------------------------------------------------------------------*/
 410          void actu_Pca1_Pid(int tempCapt,int consigne)
 411          {
 412   1         static int pwm1=0;
 413   1         static unsigned char old_error=0;
 414   1         int error=0;
 415   1         if(tempCapt<consigne)
 416   1         {
 417   2            error=consigne-tempCapt;
 418   2            pwm1=255-((int)error*KP)+((old_error-error)*KD);
 419   2            //pwm1=0;//mode tout ou rien
 420   2         }
 421   1         else
 422   1         {
 423   2            pwm1=255;//0%
 424   2            error=0;
 425   2         }
 426   1         old_error=error;
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 8   

 427   1         if(pwm1<=0)
 428   1         {
 429   2            PCA0CPM1|=0x40;//reactive la pca0 si il a ete desactiver
 430   2            PCA0CPH1=0;
 431   2         }
 432   1         else if(pwm1>=255)
 433   1         {
 434   2            PCA0CPH1=255;
 435   2            PCA0CPM1&=~0x40;//Clear ecom0 afin d'obtenir 0%
 436   2         }
 437   1         else
 438   1         {
 439   2            PCA0CPH1=pwm1;
 440   2         }
 441   1      }
 442          
 443          /*---------------------------------------------------------------------------*-
 444             actu_Pca2_Pid ()
 445            -----------------------------------------------------------------------------
 446             Descriptif: calul le pwm a appliquer sur la resistance en fonction du PID
 447             Entrée    : 
 448                         - int tempCapt
 449                         - int consigne
 450             Sortie    : --
 451          -*---------------------------------------------------------------------------*/
 452          void actu_Pca2_Pid(int tempCapt,int consigne)
 453          {
 454   1         static int pwm1=0;
 455   1         static unsigned char old_error=0;
 456   1         int error=0;
 457   1         if(tempCapt<consigne)
 458   1         {
 459   2            error=consigne-tempCapt;
 460   2            pwm1=255-((int)error*KP)+((old_error-error)*KD);
 461   2            //pwm1=0;//mode tout ou rien
 462   2         }
 463   1         else
 464   1         {
 465   2            pwm1=255;//0%
 466   2            error=0;
 467   2         }
 468   1         old_error=error;
 469   1         if(pwm1<=0)
 470   1         {
 471   2            PCA0CPM2|=0x40;//reactive la pca0 si il a ete desactiver
 472   2            PCA0CPH2=0;
 473   2         }
 474   1         else if(pwm1>=255)
 475   1         {
 476   2            PCA0CPH2=255;
 477   2            PCA0CPM2&=~0x40;//Clear ecom0 afin d'obtenir 0%
 478   2         }
 479   1         else
 480   1         {
 481   2            PCA0CPH2=pwm1;
 482   2         }
 483   1      }
 484          
 485          /*---------------------------------------------------------------------------*-
 486             actu_Pca3_Pid ()
 487            -----------------------------------------------------------------------------
 488             Descriptif: calul le pwm a appliquer sur la resistance en fonction du PID
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 9   

 489             Entrée    : 
 490                         - int tempCapt
 491                         - int consigne
 492             Sortie    : --
 493          -*---------------------------------------------------------------------------*/
 494          void actu_Pca3_Pid(int tempCapt,int consigne)
 495          {
 496   1         static int pwm1=0;
 497   1         static unsigned char old_error=0;
 498   1         int error=0;
 499   1         if(tempCapt<consigne)
 500   1         {
 501   2            error=consigne-tempCapt;
 502   2            pwm1=255-((int)error*KP)+((old_error-error)*KD);
 503   2            //pwm1=0;//mode tout ou rien
 504   2         }
 505   1         else
 506   1         {
 507   2            pwm1=255;//0%
 508   2            error=0;
 509   2         }
 510   1         old_error=error;
 511   1         if(pwm1<=0)
 512   1         {
 513   2            PCA0CPM3|=0x40;//reactive la pca0 si il a ete desactiver
 514   2            PCA0CPH3=0;
 515   2         }
 516   1         else if(pwm1>=255)
 517   1         {
 518   2            PCA0CPH3=255;
 519   2            PCA0CPM3&=~0x40;//Clear ecom0 afin d'obtenir 0%
 520   2         }
 521   1         else
 522   1         {
 523   2            PCA0CPH3=pwm1;
 524   2         }
 525   1      }
 526          
 527          /*---------------------------------------------------------------------------*-
 528          reset_i2c()
 529          -----------------------------------------------------------------------------
 530          Descriptif: Verifie si le bus I2C est bloquer, et effectue un reset du bus
 531          Entree    : --
 532          Sortie    : --
 533          -*---------------------------------------------------------------------------*/
 534          void reset_i2c()
 535          {
 536   1         unsigned char i=0;
 537   1         if(!SDA)
 538   1         {
 539   2            P0SKIP    = 0xCF;
 540   2            XBR0      = 0x01;
 541   2            // If slave is holding SDA low because of an improper SMBus reset or error
 542   2            while(!SDA)
 543   2            {
 544   3               // Provide clock pulses to allow the slave to advance out
 545   3               // of its current state. This will allow it to release SDA.
 546   3               SCL = 0;                         // Drive the clock low
 547   3               for(i = 0; i < 100; i++);        // Hold the clock low
 548   3               SCL = 1;                         // Release the clock
 549   3               for(i = 0; i < 100; i++);        // Hold the clock low
 550   3            }
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 10  

 551   2            P0SKIP    = 0x0F;
 552   2            XBR0      = 0x05;
 553   2         }
 554   1      }
 555          
 556          /*---------------------------------------------------------------------------*-
 557             getTempAmbiante ()
 558            -----------------------------------------------------------------------------
 559             Descriptif: demande la temperature au capteur EEH210
 560             Entrée    : --
 561             Sortie    : long
 562          -*---------------------------------------------------------------------------*/
 563          long getTempAmbiante()
 564          {
 565   1         while(SMB_BUSY);
 566   1               gTarget = 0x80;//0x81    (0x40 7 bit + 1 bit = 0x81 1 == read 
 567   1               gSMBDataOUT[0]  = 0xF3;//E3 = Hold master / F3 = no hold master
 568   1               gSMBNumBytesToWR = 1;
 569   1               SMB_Write();  // Initiate SMBus write
 570   1            //TEST=~TEST;
 571   1               while(SMB_BUSY);
 572   1            Delay_1ms(20);//attend la fin de mesure 
 573   1            gTarget = 0x81;
 574   1            gSMBNumBytesToRD = 4;
 575   1            SMB_Read();  // Initiate SMBus read
 576   1            //Delay_1ms(20);//attend la fin de mesure 
 577   1            
 578   1         return convertToTemp_i2c(((unsigned int )gSMBDataIN[1]<<8)+gSMBDataIN[2]);
 579   1      }
 580          
 581          /*---------------------------------------------------------------------------*-
 582             GetHumidite ()
 583            -----------------------------------------------------------------------------
 584             Descriptif: demande l'humidite ambiante au capteur EEH210
 585             Entrée    : --
 586             Sortie    : --
 587          -*---------------------------------------------------------------------------*/
 588          unsigned int GetHumidite()
 589          {
 590   1         gTarget = 0x80;//0x81    (0x40 7 bit + 1 bit = 0x81 1 == read 
 591   1               gSMBDataOUT[0]  = 0xF5;
 592   1               gSMBNumBytesToWR = 1;
 593   1               SMB_Write();  // Initiate SMBus write
 594   1               while(SMB_BUSY);
 595   1            Delay_1ms(20);//attend la fin de mesure 
 596   1            gTarget = 0x81;
 597   1            gSMBNumBytesToRD = 4;
 598   1            SMB_Read();  // Initiate SMBus read
 599   1         return convertToHumi(((unsigned int )gSMBDataIN[1]<<8)+gSMBDataIN[2]);
 600   1      }
 601          
 602          
 603          /*---------------------------------------------------------------------------*-
 604          configEeh210()
 605          -----------------------------------------------------------------------------
 606          Descriptif: Configure le capteur EEH210 
 607                   fonction incomplete, il faut lire les parametre avant d'�crire
 608                   dessus
 609          Entree    : unsigned char tab[] - la chaine de caractere a decoder
 610          Sortie    : --
 611          -*---------------------------------------------------------------------------*/
 612          void configEeh210(unsigned char mode)
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 11  

 613          {
 614   1         while(SMB_BUSY);
 615   1         gTarget = 0x80;//0x81    (0x40 7 bit + 1 bit = 0x81 1 == read 
 616   1        gSMBDataOUT[0]  = 0xE6;
 617   1         switch(mode)
 618   1         {
 619   2            case 0 :
 620   2               gSMBDataOUT[1]  = 0x3A;
 621   2            break;
 622   2            case 1 :
 623   2               gSMBDataOUT[1]  = 0x3B;
 624   2            break;
 625   2            case 2 :
 626   2               gSMBDataOUT[1]  = 0xBA;
 627   2            break;
 628   2            case 3 :
 629   2               gSMBDataOUT[1]  = 0xBB;
 630   2            break;
 631   2         }
 632   1         
 633   1        gSMBNumBytesToWR = 2;
 634   1        SMB_Write();  // Initiate SMBus write
 635   1      }
 636          
 637          /*---------------------------------------------------------------------------*-
 638          convertToTemp()
 639          -----------------------------------------------------------------------------
 640          Descriptif: Convertie une valeur sur 16 bit en temperature
 641          Entree    : unsigned int value - la donne a convertir
 642          Sortie    : long - la temperature convertie avec un facteur 100
 643          -*---------------------------------------------------------------------------*/
 644          long convertToTemp_i2c(unsigned int value)
 645          {
 646   1         value = value &~ 0x03;
 647   1         return (((long)value*17572)>>16)-4685;
 648   1      }
 649          
 650          /*---------------------------------------------------------------------------*-
 651          convertToHumi()
 652          -----------------------------------------------------------------------------
 653          Descriptif: Convertie une valeur sur 16 bit en humidit�
 654          Entree    : unsigned int value - la donne a convertir
 655          Sortie    : unsigned int - la temperature convertie
 656          -*---------------------------------------------------------------------------*/
 657          unsigned int convertToHumi(unsigned int value)
 658          {
 659   1         value = value &~ 0x03;
 660   1         return (((unsigned long)value*125)>>16)-6;;
 661   1      }
 662          
 663          /*---------------------------------------------------------------------------*-
 664          ADCInit()
 665          -----------------------------------------------------------------------------
 666          Descriptif:
 667          Pin + : P1.1
 668          Pin - : GND
 669          Aligner a Droite
 670          Conversion sur : AD0BUSY=1;
 671          Clock SAR : 2000000
 672          ref sur 
 673          Entree    : --
 674          Sortie    : --
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 12  

 675          -*---------------------------------------------------------------------------*/
 676          void ADCInit()
 677          {
 678   1      
 679   1         AMX0P=0x00;//Entree positive sur P2.0
 680   1         AMX0N=0x1f;//Entree negative sur GND
 681   1                  // +++++----- ADC0 SAR Conversion Clock Period Bits.
 682   1                  // |||||+---- AD0LJST ajustement a droite
 683   1                  // ||||||++-- Reserver
 684   1                  // ||||||||  
 685   1         ADC0CF=0xb8;// 10111000 - clk SAR de 2000000Hz aligner a droite
 686   1                     // +--------  ADC0 Enable Bit
 687   1                     // |+-------  ADC0 Track Mode Bit.
 688   1                     // ||+------- AD0INT ADC0 Conversion Complete Interrupt Flag
 689   1                     // |||+------ AD0BUSY
 690   1                     // ||||+----- ADC0 Window Compare Interrupt Flag
 691   1                     // |||||+++-- ADC0 Start of Conversion Mode Select
 692   1                     // ||||||||  
 693   1         ADC0CN=0x80;// 10000000
 694   1                     // +--------- Reference Buffer Gain Select.
 695   1                     // |++------- Unused
 696   1                     // |||+------ Regulator Reference Override
 697   1                     // ||||+----- Voltage Reference Select.
 698   1                     // |||||+---- Temperature Sensor Enable Bit
 699   1                     // ||||||+--- Internal Analog Bias Generator Enable Bit.
 700   1                     // |||||||+-- On-chip Reference Buffer Enable Bit.
 701   1                     // ||||||||  
 702   1         REF0CN=0x08;// 00010000
 703   1      
 704   1         EIE1|=0x08;
 705   1      }
 706          
 707          
 708          void decodeUart0()
 709          {
 710   1         unsigned int testPwm=0;
 711   1         int temp=0;
 712   1         //PCA0
 713   1         if((gUart0Rx[0]=='R')&&(gUart0Rx[1]=='0')&&(gUart0Rx[2]=='_'))
 714   1         {                                                             
 715   2            testPwm=(gUart0Rx[3]-'0')*100;
 716   2            testPwm+=(gUart0Rx[4]-'0')*10;
 717   2            testPwm+=gUart0Rx[5]-'0';
 718   2            if(testPwm>255)
 719   2            {
 720   3               //Erreur
 721   3               testPwm=255;
 722   3            }
 723   2            testPwm=255-testPwm;
 724   2            if(testPwm==255)//0%
 725   2            {
 726   3               PCA0CPH0=0xFF;
 727   3               PCA0CPM0&=~0x40;//RAZ de ECOMn pour forcer le pwm a 0%
 728   3            }
 729   2            else
 730   2            {
 731   3               PCA0CPH0=testPwm;
 732   3               PCA0CPM0|=0x40;//ECOMn a 1 pour autoriser le fonctionnement
 733   3            }
 734   2         }
 735   1         
 736   1         //PCA1
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 13  

 737   1         if((gUart0Rx[0]=='R')&&(gUart0Rx[1]=='1')&&(gUart0Rx[2]=='_'))
 738   1         {                                                             
 739   2            testPwm=(gUart0Rx[3]-'0')*100;
 740   2            testPwm+=(gUart0Rx[4]-'0')*10;
 741   2            testPwm+=gUart0Rx[5]-'0';
 742   2            if(testPwm>255)
 743   2            {
 744   3               //Erreur
 745   3               testPwm=255;
 746   3            }
 747   2            testPwm=255-testPwm;
 748   2            if(testPwm==255)//0%
 749   2            {
 750   3               PCA0CPH1=0xFF;
 751   3               PCA0CPM1&=~0x40;//RAZ de ECOMn pour forcer le pwm a 0%
 752   3            }
 753   2            else
 754   2            {
 755   3               PCA0CPH1=testPwm;
 756   3               PCA0CPM1|=0x40;//ECOMn a 1 pour autoriser le fonctionnement
 757   3            }
 758   2         }
 759   1         
 760   1         //PCA2
 761   1         if((gUart0Rx[0]=='R')&&(gUart0Rx[1]=='2')&&(gUart0Rx[2]=='_'))
 762   1         {                                                             //maximum 255
 763   2            testPwm=(gUart0Rx[3]-'0')*100;
 764   2            testPwm+=(gUart0Rx[4]-'0')*10;
 765   2            testPwm+=gUart0Rx[5]-'0';
 766   2            if(testPwm>255)
 767   2            {
 768   3               //Erreur
 769   3               testPwm=255;
 770   3            }
 771   2            testPwm=255-testPwm;
 772   2            if(testPwm==255)//0%
 773   2            {
 774   3               PCA0CPH2=0xFF;
 775   3               PCA0CPM2&=~0x40;//RAZ de ECOMn pour forcer le pwm a 0%
 776   3            }
 777   2            else
 778   2            {
 779   3               PCA0CPH2=testPwm;
 780   3               PCA0CPM2|=0x40;//ECOMn a 1 pour autoriser le fonctionnement
 781   3            }
 782   2         }
 783   1         
 784   1         //PCA3
 785   1         if((gUart0Rx[0]=='R')&&(gUart0Rx[1]=='3')&&(gUart0Rx[2]=='_'))
 786   1         {                                                             //maximum 255
 787   2            testPwm=(gUart0Rx[3]-'0')*100;
 788   2            testPwm+=(gUart0Rx[4]-'0')*10;
 789   2            testPwm+=gUart0Rx[5]-'0';
 790   2            if(testPwm>255)
 791   2            {
 792   3               //Erreur
 793   3               testPwm=255;
 794   3            }
 795   2            testPwm=255-testPwm;
 796   2            if(testPwm==255)//0%
 797   2            {
 798   3               PCA0CPH3=0xFF;
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 14  

 799   3               PCA0CPM3&=~0x40;//RAZ de ECOMn pour forcer le pwm a 0%
 800   3            }
 801   2            else
 802   2            {
 803   3               PCA0CPH3=testPwm;
 804   3               PCA0CPM3|=0x40;//ECOMn a 1 pour autoriser le fonctionnement
 805   3            }
 806   2         }
 807   1         
 808   1         if((gUart0Rx[0]=='G')&&(gUart0Rx[1]=='E')&&(gUart0Rx[2]=='T')&&(gUart0Rx[3]=='_')&&(gUart0Rx[4]=='T'))
 809   1         {
 810   2            if(gUart0Rx[5]=='0')//Capteur_i2c
 811   2            {
 812   3               temp=getTempAmbiante();
 813   3               temp=temp/10;
 814   3            }
 815   2            else if(gUart0Rx[5]=='1')//LM35_0
 816   2            {
 817   3               temp=convertLm35ToTemp(gMesureAvg[LM35_0_POS],gMesureAvg[LM35_0_NEG]);
 818   3            }
 819   2            else if(gUart0Rx[5]=='2')//LM35_1
 820   2            {
 821   3               temp=convertLm35ToTemp(gMesureAvg[LM35_1_POS],gMesureAvg[LM35_1_NEG]);
 822   3            }
 823   2            else if(gUart0Rx[5]=='3')//LM35_2
 824   2            {
 825   3               temp=convertLm35ToTemp(gMesureAvg[LM35_2_POS],gMesureAvg[LM35_2_NEG]);
 826   3            }
 827   2            else if(gUart0Rx[5]=='4')//LM35_3
 828   2            {
 829   3               temp=convertLm35ToTemp(gMesureAvg[LM35_3_POS],gMesureAvg[LM35_3_NEG]);
 830   3            }
 831   2            else if(gUart0Rx[5]=='R')//LM35_3
 832   2            {
 833   3               temp=calculRose(getTempAmbiante(), GetHumidite());
 834   3            }
 835   2            else
 836   2            {
 837   3               temp=999;//Erreur
 838   3            }
 839   2            
 840   2            //envoie sur l'uart0
 841   2            if(temp>=0)
 842   2            {
 843   3               gUart0Tx[0]='+';
 844   3            }
 845   2            else
 846   2            {
 847   3               gUart0Tx[0]='-';
 848   3               temp=temp*(-1);
 849   3            }
 850   2            //ex pour 28.3�C --> 283
 851   2            //gUart0Tx[1]=(temp/1000)+'0';//2
 852   2            gUart0Tx[1]=(temp/100)+'0';//2
 853   2            gUart0Tx[2]=((temp%100)/10)+'0';//8
 854   2            gUart0Tx[3]='.';                       //.
 855   2            gUart0Tx[4]=((temp%10))+'0';//3
 856   2            gUart0Tx[5]='\n';
 857   2            gUart0Tx[6]=0;
 858   2            gUart0NbrByteTx=0;
 859   2            TI0=1;
 860   2         }
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 15  

 861   1         
 862   1         if((gUart0Rx[0]=='G')&&(gUart0Rx[1]=='E')&&(gUart0Rx[2]=='T')&&(gUart0Rx[3]=='_')&&(gUart0Rx[4]=='H'))
 863   1         {
 864   2            temp=GetHumidite();
 865   2            gUart0Tx[0]=(temp/100)+'0';
 866   2            gUart0Tx[1]=(temp/10)+'0';
 867   2            gUart0Tx[2]=((temp%10))+'0';
 868   2            gUart0Tx[3]='\n';
 869   2            gUart0Tx[4]=0;
 870   2            gUart0NbrByteTx=0;
 871   2            TI0=1;
 872   2         }
 873   1      }
 874          
 875          /*---------------------------------------------------------------------------*-
 876          TimerInit ()
 877          -----------------------------------------------------------------------------
 878          Descriptif:
 879          Timer 0 : Mode 16bit - Prediv 48 - tempo 50milli
 880          Timer 1 : Mode 8bit - Prediv 48 - vitesse : 57600bit/s
 881          Entree    : --
 882          Sortie    : --
 883          -*---------------------------------------------------------------------------*/
 884          void TimerInit()
 885          {
 886   1      TR0 = 0;//Stop le timer 0
 887   1      TR1 = 0;//Stop le timer 1
 888   1      ET0 = 0;//Desactive l'interruption du timer 0
 889   1      ET1 = 0;//Desactive l'interruption du timer 1
 890   1      TMOD &= ~0xFF;//Clear le registre des mode
 891   1                   // +-------- Timer 1 Gate Control
 892   1                   // |+------- Counter/Timer1 Select
 893   1                   // ||++----- choix du mode du timer 1
 894   1                   // ||||+---- Timer 0 Gate Control
 895   1                   // |||||+--- Counter/Timer0 Select
 896   1                   // ||||||++- choix du mode du timer 0
 897   1                   // ||||||||  (00 : Mode 0, 13-bit Counter/Timer)
 898   1                   // ||||||||  (01 : Mode 1, 16-bit Counter/Timer)
 899   1                   // ||||||||  (10 : Mode 2, 8-bit Counter/Timer with Auto-Reload)
 900   1                   // ||||||||  (11 : Mode 3, Two 8-bit Counter/Timers)  
 901   1      TMOD |= 0x21;// 00100001
 902   1      CKCON &= ~0x07;//clear les bit de selection pour les timer 0 et 1 et le prescalaire
 903   1                    // +-------- Timer 3 High Byte Clock Select.
 904   1                    // |+------- Timer 3 Low Byte Clock Select.
 905   1                    // ||+------ Timer 2 High Byte Clock Select
 906   1                    // |||+----- Timer 2 Low Byte Clock Select.
 907   1                    // ||||+---- Timer 1 Clock Select.
 908   1                    // |||||+--- Timer 0 Clock Select.
 909   1                    // ||||||++- Timer 0/1 Prescale Bits.
 910   1                    // ||||||||  (00: System clock divided by 12)
 911   1                    // ||||||||  (01: System clock divided by 4)
 912   1                    // ||||||||  (10: System clock divided by 48)
 913   1                    // ||||||||  (11: External clock divided by 8 (synchronized with the system clock))  
 914   1      CKCON |= 0x02;// 00000010
 915   1      TH0=LOADVALUE_T0/256;//Charge la valeur dans le registre MSB du timer 0
 916   1      TL0=LOADVALUE_T0%256;//Charge la valeur dans le registre LSB du timer 0
 917   1      TL1=TH1=LOADVALUE_BAUD;//Charge la valeur du timer 1
 918   1      TF0 = 0;//clear le flag d'interruption du timer 0
 919   1      TF1 = 0;//clear le flag d'interruption du timer 1
 920   1      ET0 = 1;//Autorise l'interruption du timer 0
 921   1      ET1 = 0;//Autorise l'interruption du timer 1
 922   1      }
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 16  

 923          
 924          
 925          
 926          void PCA_Init()
 927          {
 928   1          PCA0CN    = 0x40;//Active le PCA
 929   1          PCA0MD    |= 0x02;//PCA SYSCLK Prediv
 930   1          PCA0CPM0  = 0x42;//active le mode PWM et le comparateur du PCA0
 931   1          PCA0CPM1  = 0x42;//active le mode PWM et le comparateur du PCA1
 932   1         PCA0CPM2  = 0x42;//active le mode PWM et le comparateur du PCA0
 933   1          PCA0CPM3  = 0x42;//active le mode PWM et le comparateur du PCA1
 934   1         PCA0CPH0  = 0xFF;//valeur a charger pour obtenir %
 935   1         PCA0CPH1  = 0xFF;//valeur a charger pour obtenir %
 936   1         PCA0CPH2  = 0xFF;//valeur a charger pour obtenir %
 937   1         PCA0CPH3  = 0xFF;//valeur a charger pour obtenir %
 938   1      }
 939          
 940          /*---------------------------------------------------------------------------*-
 941             ClockInit ()
 942            -----------------------------------------------------------------------------
 943             Descriptif: Initialisation du mode de fonctionnement du clock syst�me 
 944                   choix : SYSCLK : oscillateur HF interne � 48 MHz
 945          
 946             Entr�e    : --
 947             Sortie    : --
 948          -*---------------------------------------------------------------------------*/
 949          void ClockInit()
 950          {  
 951   1         
 952   1                           // +--------- clock interne LF
 953   1                           // | (1 : oscillateur LF : enable)
 954   1                           // | (0 : oscillateur LF: desable)
 955   1                           // |+-------- en lecture seule 1 : signal que oscillateur 
 956   1                           // ||         interne fonctionne � sa valeur de prog.
 957   1                           // ||++++---- r�glage fin de la fr�quence de l'osc. LF
 958   1                           // ||||||++-- choix du diviseur :
 959   1                           // ||||||||       (00 : Osc LF /8 -> f = 10 KHz)
 960   1                           // ||||||||       (01 : Osc LF /4 -> f = 20 KHz)
 961   1                           // ||||||||       (10 : Osc LF /2 -> f = 40 KHz)
 962   1                           // ||||||||       (11 : Osc LF /1 -> f = 80 KHz)
 963   1         OSCLCN |= 0x00;   // 00000000 
 964   1      
 965   1                           // +--------- non utilis�
 966   1                           // |+++------ S�lection du clock USB 
 967   1                           // ||||           (010 : Oscil ext. : limiter la conso.)
 968   1                           // ||||+----- clock out select
 969   1                           // |||||          (0 : sortie sysclk non synchronis�e)
 970   1                           // |||||          (1 : sortie sysclk synchronis�e)
 971   1                           // |||||+++-- choix du clock syst�me
 972   1                           // ||||||||       (000 : Oscil interne 48/4  = 1.5, 3, 6 ou
 973   1                           // ||||||||              12 MHz selon le choix du diviseur 
 974   1                           // ||||||||              dans OSCICN
 975   1                           // ||||||||       (001 : Oscil externe  = x  MHz)
 976   1                           // ||||||||       (010 : Oscil interne 48/2 = 24 MHz)
 977   1                           // ||||||||       (011 : Oscil interne 48/1 = 48 MHz)    
 978   1                           // ||||||||       (100 : Oscil interne LF = 80 KHz max)   
 979   1                           // ||||||||       (101 � 111 : r�serv�s)   
 980   1         CLKSEL = 0x03;    // 00000011  
 981   1      
 982   1                           // +--------- clock interne HF
 983   1                           // |              (1 : oscillateur LF : enable)
 984   1                           // |              (0 : oscillateur LF: desable)
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 17  

 985   1                           // |+-------- en lecture seule 1 : signal que oscillateur 
 986   1                           // ||              interne fonctionne � sa valeur de prog.
 987   1                           // ||+------- 1 : suspend l'oscillateur interne
 988   1                           // |||+++---- non utilis�s
 989   1                           // ||||||++-- choix du diviseur :
 990   1                           // ||||||||       (00 : 12/8 -> f =  1.5 MHz)
 991   1                           // ||||||||       (01 : 12/4 -> f =  3   MHz)
 992   1                           // ||||||||       (10 : 12/2 -> f =  6   MHz)
 993   1                           // ||||||||       (11 : 12/1 -> f = 12   MHz)
 994   1         OSCICN = 0xC3;    // 11000011 
 995   1         
 996   1         FLSCL = 0x90;     // A utiliser si le clock system est � 48 MHz
 997   1      
 998   1      } // ClockInit ----------------------------------------------------------------
 999          
1000          
1001          //-----------------------------------------------------------------------------
1002          // SMBus_Init
1003          //-----------------------------------------------------------------------------
1004          //
1005          // Return Value : None
1006          // Parameters   : None
1007          //
1008          // SMBus configured as follows:
1009          // - SMBus enabled
1010          // - Slave mode inhibited
1011          // - Timer2 used as clock source. The maximum SCL frequency will be
1012          //   approximately 1/3 the Timer1 overflow rate
1013          // - Setup and hold time extensions enabled
1014          // - Bus Free and SCL Low timeout detection enabled
1015          //
1016          void SMBus_Init (void)
1017          {
1018   1         SMB0CF = 0x5E;                      // Use Timer2 overflows as SMBus clock
1019   1                                             // source;
1020   1                                             // Disable slave mode;
1021   1                                             // Enable setup & hold time
1022   1                                             // extensions;
1023   1                                             // Enable SMBus Free timeout detect;
1024   1                                             // Enable SCL low timeout detect;
1025   1      
1026   1         SMB0CF |= 0x80;                     // Enable SMBus;
1027   1      }
1028          
1029          
1030          //-----------------------------------------------------------------------------
1031          // Timer2_Init
1032          //-----------------------------------------------------------------------------
1033          //
1034          // Return Value : None
1035          // Parameters   : None
1036          //
1037          // Timer2 configured as the SMBus clock source as follows:
1038          // - Timer2 in 8-bit auto-reload mode
1039          // - SYSCLK or SYSCLK / 4 as Timer1 clock source
1040          // - Timer2 overflow rate => 3 * SMB_FREQUENCY
1041          // - The resulting SCL clock rate will be ~1/3 the Timer2 overflow rate
1042          // - Timer2 enabled
1043          //
1044          void Timer2_Init (void)
1045          {
1046   1         TMR2CN    |= 0x0C;
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 18  

1047   1         TMR2RLH   |= 0xD4;
1048   1      }
1049          
1050          //-----------------------------------------------------------------------------
1051          // Timer3_Init
1052          //-----------------------------------------------------------------------------
1053          //
1054          // Return Value : None
1055          // Parameters   : None
1056          //
1057          // Timer3 configured for use by the SMBus low timeout detect feature as
1058          // follows:
1059          // - Timer3 in 16-bit auto-reload mode
1060          // - SYSCLK/12 as Timer3 clock source
1061          // - Timer3 reload registers loaded for a 25ms overflow period
1062          // - Timer3 pre-loaded to overflow after 25ms
1063          // - Timer3 enabled
1064          //
1065          void Timer3_Init (void)
1066          {
1067   1         TMR3CN = 0x00;                      // Timer3 configured for 16-bit auto-
1068   1                                             // reload, low-byte interrupt disabled
1069   1      
1070   1         CKCON &= ~0x40;                     // Timer3 uses SYSCLK/12
1071   1      
1072   1         TMR3RL = -(SYSCLK/12/40);           // Timer3 configured to overflow after
1073   1         TMR3 = TMR3RL;                      // ~25ms (for SMBus low timeout detect):
1074   1                                             // 1/.025 = 40
1075   1      
1076   1         EIE1 |= 0x80;                       // Timer3 interrupt enable
1077   1         TMR3CN |= 0x04;                     // Start Timer3
1078   1      }
1079          
1080          //-----------------------------------------------------------------------------
1081          // SMBus Interrupt Service Routine (ISR)
1082          //-----------------------------------------------------------------------------
1083          //
1084          // SMBus ISR state machine
1085          // - Master only implementation - no slave or arbitration states defined
1086          // - All incoming data is written to global variable array <gSMBDataIN>
1087          // - All outgoing data is read from global variable array <gSMBDataOUT>
1088          //
1089          void SMBus_ISR (void) interrupt 7
1090          {
1091   1         bit FAIL = 0;                       // Used by the ISR to flag failed
1092   1                                             // transfers
1093   1      
1094   1         static unsigned char sent_byte_counter;
1095   1         static unsigned char rec_byte_counter;
1096   1      
1097   1         if (ARBLOST0 == 0)                   // Check for errors
1098   1         {
1099   2            // Normal operation
1100   2            switch (SMB0CN & 0xF0)           // Status vector
1101   2            {
1102   3               // Master Transmitter/Receiver: START condition transmitted.
1103   3               case SMB_MTSTA:
1104   3                  SMB0DAT = gTarget;          // Load address of the gTarget slave
1105   3                  SMB0DAT &= 0xFE;           // Clear the LSB of the address for the
1106   3                                             // R/W bit
1107   3                  SMB0DAT |= SMB_RW;         // Load R/W bit
1108   3                  STA0 = 0;                   // Manually clear START bit
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 19  

1109   3                  rec_byte_counter = 1;      // Reset the counter
1110   3                  sent_byte_counter = 1;     // Reset the counter
1111   3                  break;
1112   3      
1113   3               // Master Transmitter: Data byte transmitted
1114   3               case SMB_MTDB:
1115   3                  if (ACK0)                   // Slave ACK0?
1116   3                  {
1117   4                     if (SMB_RW == WRITE)    // If this transfer is a WRITE,
1118   4                     {
1119   5                        if (sent_byte_counter <= gSMBNumBytesToWR)
1120   5                        {
1121   6                           // send data byte
1122   6                           SMB0DAT = gSMBDataOUT[sent_byte_counter-1];
1123   6                           sent_byte_counter++;
1124   6                        }
1125   5                        else
1126   5                        {
1127   6                           STO0 = 1;          // Set STO0 to terminate transfer
1128   6                           SMB_BUSY = 0;     // And free SMBus interface
1129   6                        }
1130   5                     }
1131   4                     else {}                 // If this transfer is a READ,
1132   4                                             // proceed with transfer without
1133   4                                             // writing to SMB0DAT (switch
1134   4                                             // to receive mode)
1135   4      
1136   4      
1137   4                  }
1138   3                  else                       // If slave NACK,
1139   3                  {
1140   4                     STO0 = 1;                // Send STOP condition, followed
1141   4                     STA0 = 1;                // By a START
1142   4                     NUM_ERRORS++;           // Indicate error
1143   4                  }
1144   3                  break;
1145   3      
1146   3               // Master Receiver: byte received
1147   3               case SMB_MRDB:
1148   3                  if (rec_byte_counter < gSMBNumBytesToRD)
1149   3                  {
1150   4                     gSMBDataIN[rec_byte_counter-1] = SMB0DAT; // Store received
1151   4                                                                // byte
1152   4                     ACK0 = 1;                // Send ACK0 to indicate byte received
1153   4                     rec_byte_counter++;     // Increment the byte counter
1154   4                  }
1155   3                  else
1156   3                  {
1157   4                     gSMBDataIN[rec_byte_counter-1] = SMB0DAT; // Store received
1158   4                                                                // byte
1159   4                     SMB_BUSY = 0;           // Free SMBus interface
1160   4                     ACK0 = 0;                // Send NACK to indicate last byte
1161   4                                             // of this transfer
1162   4      
1163   4                     STO0 = 1;                // Send STOP to terminate transfer
1164   4                  }
1165   3                  break;
1166   3      
1167   3               default:
1168   3                  FAIL = 1;                  // Indicate failed transfer
1169   3                                             // and handle at end of ISR
1170   3                  break;
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 20  

1171   3      
1172   3            } // end switch
1173   2         }
1174   1         else
1175   1         {
1176   2            // ARBLOST = 1, error occurred... abort transmission
1177   2            FAIL = 1;
1178   2         } // end ARBLOST if
1179   1      
1180   1         if (FAIL)                           // If the transfer failed,
1181   1         {
1182   2            SMB0CF &= ~0x80;                 // Reset communication
1183   2            SMB0CF |= 0x80;
1184   2            STA0 = 0;
1185   2            STO0 = 0;
1186   2            ACK0 = 0;
1187   2      
1188   2            SMB_BUSY = 0;                    // Free SMBus
1189   2      
1190   2            FAIL = 0;
1191   2            //LED = 0;
1192   2      
1193   2            NUM_ERRORS++;                    // Indicate an error occurred
1194   2         }
1195   1      
1196   1         SI0 = 0;                             // Clear interrupt flag
1197   1      }
1198          
1199          //-----------------------------------------------------------------------------
1200          // Timer3 Interrupt Service Routine (ISR)
1201          //-----------------------------------------------------------------------------
1202          //
1203          // A Timer3 interrupt indicates an SMBus SCL low timeout.
1204          // The SMBus is disabled and re-enabled here
1205          //
1206          void Timer3_ISR (void) interrupt 14
1207          {
1208   1         SMB0CF &= ~0x80;                    // Disable SMBus
1209   1         SMB0CF |= 0x80;                     // Re-enable SMBus
1210   1         TMR3CN &= ~0x80;                    // Clear Timer3 interrupt-pending
1211   1                                             // flag
1212   1         STA0 = 0;
1213   1         SMB_BUSY = 0;                       // Free SMBus
1214   1      }
1215          
1216          
1217          //-----------------------------------------------------------------------------
1218          // Support Functions
1219          //-----------------------------------------------------------------------------
1220          
1221          //-----------------------------------------------------------------------------
1222          // SMB_Write
1223          //-----------------------------------------------------------------------------
1224          //
1225          // Return Value : None
1226          // Parameters   : None
1227          //
1228          // Writes a single byte to the slave with address specified by the <gTarget>
1229          // variable.
1230          // Calling sequence:
1231          // 1) Write gTarget slave address to the <gTarget> variable
1232          // 2) Write outgoing data to the <gSMBDataOUT> variable array
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 21  

1233          // 3) Call SMB_Write()
1234          //
1235          void SMB_Write (void)
1236          {
1237   1         while (SMB_BUSY);                   // Wait for SMBus to be free.
1238   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
1239   1         SMB_RW = 0;                         // Mark this transfer as a WRITE
1240   1         STA0 = 1;                            // Start transfer
1241   1      }
1242          
1243          //-----------------------------------------------------------------------------
1244          // SMB_Read
1245          //-----------------------------------------------------------------------------
1246          //
1247          // Return Value : None
1248          // Parameters   : None
1249          //
1250          // Reads a single byte from the slave with address specified by the <gTarget>
1251          // variable.
1252          // Calling sequence:
1253          // 1) Write gTarget slave address to the <gTarget> variable
1254          // 2) Call SMB_Write()
1255          // 3) Read input data from <gSMBDataIN> variable array
1256          //
1257          void SMB_Read (void)
1258          {
1259   1         while (SMB_BUSY);                   // Wait for bus to be free.
1260   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
1261   1         SMB_RW = 1;                         // Mark this transfer as a READ
1262   1      
1263   1         STA0 = 1;                            // Start transfer
1264   1      
1265   1         while (SMB_BUSY);                   // Wait for transfer to complete
1266   1      }
1267          
1268          /*---------------------------------------------------------------------------*-
1269             Uart0Init()
1270            -----------------------------------------------------------------------------
1271             Descriptif:  Active la reception de l'UART0 - Mode 8 bit
1272             Entree    : --
1273             Sortie    : --
1274          -*---------------------------------------------------------------------------*/
1275          void Uart0Init()
1276          {  
1277   1         //Les bit font partie du registre SCON0
1278   1      
1279   1         //Serial Port 0 Operation Mode.
1280   1         //0: 8-bit UART with Variable Baud Rate.
1281   1         //1: 9-bit UART with Variable Baud Rate.
1282   1         S0MODE=0;
1283   1      
1284   1         //Multiprocessor Communication Enable.
1285   1         //The function of this bit is dependent on the Serial Port 0 Operation Mode:
1286   1         //Mode 0: Checks for valid stop bit.
1287   1         //0: Logic level of stop bit is ignored.
1288   1         //1: RI0 will only be activated if stop bit is logic level 1.
1289   1         //Mode 1: Multiprocessor Communications Enable.
1290   1         //0: Logic level of ninth bit is ignored.
1291   1         //1: RI0 is set and an interrupt is generated only when the ninth bit is logic 1.
1292   1         MCE0=0;
1293   1      
1294   1         //Receive Enable.
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 22  

1295   1         //0: UART0 reception disabled.
1296   1         //1: UART0 reception enabled.
1297   1         REN0=1;
1298   1      
1299   1         //Ninth Transmission Bit.
1300   1         //The logic level of this bit will be sent as the ninth transmission bit in 9-bit UART Mode 
1301   1         //(Mode 1). Unused in 8-bit mode (Mode 0).
1302   1         TB80=0;
1303   1      
1304   1         //Ninth Receive Bit.
1305   1         //RB80 is assigned the value of the STOP bit in Mode 0; it is assigned the value of the
1306   1         //9th data bit in Mode 1.
1307   1         RB80=0;
1308   1      
1309   1         //Transmit Interrupt Flag.
1310   1         TI0=0;
1311   1      
1312   1         //Receive Interrupt Flag. 
1313   1         RI0=0;
1314   1      } // Uart0Init ----------------------------------------------------------------
1315          
1316          
1317          /*---------------------------------------------------------------------------*-
1318             PortInit ()
1319            -----------------------------------------------------------------------------
1320             Descriptif: autorise le fonctionnement du crossbar et de l'uart0
1321             Entrée    : --
1322             Sortie    : --
1323          -*---------------------------------------------------------------------------*/
1324          void PortInit () 
1325          {
1326   1         // P0.0  -  Skipped,     Open-Drain, Digital
1327   1          // P0.1  -  Skipped,     Open-Drain, Digital
1328   1          // P0.2  -  Skipped,     Open-Drain, Digital
1329   1          // P0.3  -  Skipped,     Open-Drain, Digital
1330   1          // P0.4  -  TX0 (UART0), Push-Pull,  Digital
1331   1          // P0.5  -  RX0 (UART0), Open-Drain, Digital
1332   1          // P0.6  -  SDA (SMBus0), Open-Drain, Digital
1333   1          // P0.7  -  SCL (SMBus0), Push-Pull,  Digital
1334   1      
1335   1          // P1.0  -  Skipped,     Open-Drain, Analog
1336   1          // P1.1  -  Skipped,     Open-Drain, Analog
1337   1          // P1.2  -  Skipped,     Open-Drain, Analog
1338   1          // P1.3  -  Skipped,     Open-Drain, Analog
1339   1          // P1.4  -  Skipped,     Open-Drain, Analog
1340   1          // P1.5  -  Skipped,     Open-Drain, Analog
1341   1          // P1.6  -  Skipped,     Open-Drain, Analog
1342   1          // P1.7  -  Skipped,     Open-Drain, Analog
1343   1      
1344   1          // P2.0  -  Skipped,     Open-Drain, Analog
1345   1          // P2.1  -  Skipped,     Open-Drain, Analog
1346   1          // P2.2  -  Skipped,     Open-Drain, Analog
1347   1          // P2.3  -  Skipped,     Open-Drain, Analog
1348   1          // P2.4  -  CEX0  (PCA), Push-Pull,  Digital
1349   1          // P2.5  -  CEX1  (PCA), Push-Pull,  Digital
1350   1          // P2.6  -  CEX2  (PCA), Push-Pull,  Digital
1351   1          // P2.7  -  CEX3  (PCA), Push-Pull,  Digital
1352   1      
1353   1          // P3.0  -  Unassigned,  Open-Drain, Digital
1354   1      
1355   1          P1MDIN    = 0x00;
1356   1          P2MDIN    = 0xF0;
C51 COMPILER V9.56.0.0   SLAVE_TELESCOPE                                                   06/07/2019 09:07:00 PAGE 23  

1357   1          P0MDOUT   = 0x90;
1358   1          P2MDOUT   = 0xF0;
1359   1          P0SKIP    = 0x0F;
1360   1          P1SKIP    = 0xFF;
1361   1          P2SKIP    = 0x0F;
1362   1          XBR0      = 0x05;
1363   1          XBR1      = 0x44;
1364   1      
1365   1      } // PortInit ----------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4065    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    310    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =    100    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      7    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

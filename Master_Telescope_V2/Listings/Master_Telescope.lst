C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MASTER_TELESCOPE
OBJECT MODULE PLACED IN .\Objects\Master_Telescope.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Master_Telescope.c OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\L
                    -istings\Master_Telescope.lst) TABS(3) OBJECT(.\Objects\Master_Telescope.obj)

line level    source

   1          /*===========================================================================*=
   2             Master_Telescope - Tanguy Dietrich
   3            =============================================================================
   4             Descriptif: 
   5             Gestion de moteur d'une monture NEQ5.
   6             Le moteur R.A a une vitesse constante correspondant a la vitesse sideral.
   7             Le moteur DEC est activer lorsque la pin p2.2 ou P2.3(ST4) sont a 0
   8             Le tout est commander avec un port ST4
   9          =*===========================================================================*/
  10          
  11          #include <reg51f380.h>     // registres 51f38C
  12          #include "Vitesse_Moteur.h"
  13          #include "Delay48M.h"
  14          #include "SmBus0.h"
  15          #include "string.h"
  16          
  17          #define CONFIG_PAGE 0x0F
  18          #define LEGACY_PAGE 0x00
  19          #define BAUD_UART0 247 //247=57600
  20          
  21          //PCB
  22          sbit STEP_RA = P1^3;
  23          sbit DIR_RA = P1^2;
  24          sbit NSLEEP_RA = P1^0;
  25          sbit NFAULT_RA = P1^1;
  26          
  27          sbit STEP_DEC = P1^7;
  28          sbit DIR_DEC = P1^6;
  29          sbit NSLEEP_DEC = P1^4;
  30          sbit NFAULT_DEC = P1^5;
  31          
  32          sbit ST4_RA_NEG = P2^0;
  33          sbit ST4_RA_POS = P2^1;
  34          sbit ST4_DEC_NEG = P2^2;
  35          sbit ST4_DEC_POS = P2^3;
  36          
  37          sbit SDA = P0^0;
  38          sbit SCL = P0^1;
  39          
  40          
  41          // ==== FONCTIONS PROTOTYPES===================================================
  42          void ClockInit ();         // init. clock système
  43          void PortInit ();          // init. config des ports
  44          void TimerInit();
  45          void Init_int();
  46          void SMBus_Init (void);
  47          void Timer3_Init (void);
  48          void Timer2_Init (void);
  49          void SMB_Write (void);
  50          void SMB_Read (void);
  51          void UART_Init();
  52          void decodeUartRaspberryPi();
  53          void setMotorRA(unsigned char vitesse,bit direction);
  54          void setMotorDEC(unsigned char vitesse,bit direction);
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 2   

  55          void stopMotorDec();
  56          void configMCP23008(unsigned char input);
  57          unsigned char read_i2c_port();
  58          void reset_i2c();
  59          // ==== MAIN ==================================================================
  60          
  61          //SMBus0
  62          unsigned char gSMBNumBytesToWR = 2; // Number of bytes to write
  63                                              // Master -> Slave
  64          unsigned char gSMBNumBytesToRD = 3; // Number of bytes to read
  65                                              // Master <- Slave
  66          
  67          // Global holder for SMBus data
  68          // All receive data is written here
  69          unsigned char gSMBDataIN[NUM_BYTES_MAX_RD];
  70          
  71          // Global holder for SMBus data.
  72          // All transmit data is read from here
  73          unsigned char gSMBDataOUT[NUM_BYTES_MAX_WR];
  74          
  75          unsigned char gTarget;                  // gTarget SMBus slave address
  76          
  77          bit SMB_BUSY;                          // Software flag to indicate when the
  78                                                 // SMB_Read() or SMB_Write() functions
  79                                                 // have claimed the SMBus
  80          
  81          bit SMB_RW;                            // Software flag to indicate the
  82                                                 // direction of the current transfer
  83          
  84          unsigned long NUM_ERRORS;              // Counter for the number of errors.
  85          
  86          
  87          
  88          
  89          //Gestion Moteur
  90          unsigned char gVitesseRAH=VITESSE_RA_SIDERAL_HIGH;
  91          unsigned char gVitesseRAL=VITESSE_RA_SIDERAL_LOW;
  92          unsigned int gVitesseDEC=VITESSE_DEC_MAX;
  93          unsigned char gVitesseDeplacement=VITESSE_MAX;
  94          
  95          //Uart
  96          xdata unsigned char gUart0Tx[10]="";
  97          xdata unsigned char gUart0Rx[10];
  98          unsigned char gUart0NbrByteTx=0;
  99          unsigned char gUart0NbrByteRx=0;
 100          bit gUart0FlagReceive;
 101          
 102          xdata unsigned char gUart1Tx[10]="";
 103          xdata unsigned char gUart1Rx[10];
 104          unsigned char gUart1NbrByteTx=0;
 105          unsigned char gUart1NbrByteRx=0;
 106          bit gUart1FlagReceive;
 107          bit gDirRa=0;
 108          bit gDirDec=0;
 109          unsigned char gAstrSuivi=0;
 110          bit gFlagMovingRA=0;
 111          
 112          void main () 
 113          {
 114   1         unsigned char portExtender;
 115   1         unsigned char memoAstreSuivi=0;
 116   1         bit waitEndMove=0;
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 3   

 117   1         PCA0MD &= ~0x40;     // WDTE = 0 (disable watchdog timer)
 118   1         ClockInit ();        // init. clock système
 119   1         PortInit ();         // init. config des ports
 120   1         SDA=1;
 121   1         reset_i2c();
 122   1         Init_int();
 123   1         Timer3_Init();                      // Configure Timer3 for use with SMBus
 124   1                                             // low timeout detect
 125   1         Timer2_Init();
 126   1      
 127   1         SMBus_Init ();                      // Configure and enable SMBus
 128   1         UART_Init();
 129   1         TimerInit();
 130   1         EA=1;//Autorise toutes les interruption
 131   1         EIE1      |= 0x81;
 132   1          EIE2      |= 0x12;
 133   1          IE        |= 0x97;
 134   1         TR0 = 1;//lance le timer 0
 135   1         TR1=1;
 136   1         NSLEEP_RA=1;//Active le chip drv8825
 137   1         NSLEEP_DEC=0;
 138   1         DIR_RA=0;
 139   1         DIR_DEC=0;
 140   1         
 141   1         SDA=1;
 142   1         Delay_1ms (20);
 143   1         configMCP23008(0xFF);
 144   1         portExtender=read_i2c_port();
 145   1         gAstrSuivi=(portExtender>>4);
 146   1         memoAstreSuivi=gAstrSuivi;
 147   1         while (1)
 148   1         {
 149   2            memoAstreSuivi=gAstrSuivi;
 150   2            
 151   2            gVitesseDeplacement=(P2>>4)+4;
 152   2            portExtender=read_i2c_port();
 153   2            gAstrSuivi=(portExtender>>4);
 154   2            gDirRa=(portExtender&0x04)>>2;
 155   2            gDirDec=(portExtender&0x08)>>3;
 156   2            
 157   2            if((memoAstreSuivi!=gAstrSuivi)||(waitEndMove==1))
 158   2            {
 159   3               waitEndMove=1;
 160   3               if(gFlagMovingRA==0)
 161   3               {
 162   4                  setMotorRA(gAstrSuivi,gDirRa);
 163   4                  waitEndMove=0;
 164   4               }
 165   3            }
 166   2            
 167   2            if((NFAULT_RA==0)&&(NSLEEP_RA==1))//probleme sur le DRV8825 de l'axe R.A
 168   2            {
 169   3               NSLEEP_RA=0;
 170   3               Delay_1ms (10);
 171   3               NSLEEP_RA=1;
 172   3               Delay_1ms (10);//1.7ms necessaire au rallumage
 173   3            }
 174   2            
 175   2            if((NFAULT_DEC==0)&&(NSLEEP_DEC==1))//probleme sur le DRV8825 de l'axe DEC
 176   2            {
 177   3               NSLEEP_DEC=0;//Eteint
 178   3               Delay_1ms (10);
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 4   

 179   3               NSLEEP_DEC=1;//Allume
 180   3               Delay_1ms (10);
 181   3            }
 182   2            
 183   2            if(gUart0FlagReceive)
 184   2            {
 185   3               gUart0FlagReceive=0;
 186   3               while(gUart0NbrByteTx!=0);
 187   3               decodeUartRaspberryPi();
 188   3            }
 189   2            
 190   2            if(gUart1FlagReceive)
 191   2            {
 192   3               while(gUart0NbrByteTx!=0);
 193   3               gUart1FlagReceive=0;
 194   3               strcpy(gUart0Tx,gUart1Rx);
 195   3               TI0=1;
 196   3            }
 197   2            
 198   2         } // End while (1)
 199   1      } // main =====================================================================
 200          
 201          void reset_i2c()
 202          {
 203   1         unsigned char i=0;
 204   1         if(!SDA)
 205   1         {
 206   2            //Desactive tout l'I2C
 207   2            P0SKIP    = 0x03;//skip les pin SCL SDA
 208   2            XBR0      = 0x01;//desactive l'I2C
 209   2            //force le slave a sortir des donnee
 210   2            while(!SDA)
 211   2            {
 212   3               // Provide clock pulses to allow the slave to advance out
 213   3               // of its current state. This will allow it to release SDA.
 214   3               SCL = 0;                         // Drive the clock low
 215   3               for(i = 0; i < 100; i++);        // Hold the clock low
 216   3               SCL = 1;                         // Release the clock
 217   3               for(i = 0; i < 100; i++);        // Hold the clock low
 218   3            }
 219   2            P0SKIP    = 0x00;//Enleve les skip de pin SDA et SCL
 220   2            XBR0      = 0x05;//reactive l'i2c
 221   2         }
 222   1      }
 223          
 224          void configMCP23008(unsigned char input)
 225          {
 226   1         gTarget = MCP23008_ADDR;       // gTarget the Slave for next SMBus transfer
 227   1         gSMBDataOUT[0]  = MCP23008_IODIR;
 228   1         gSMBDataOUT[1]  = input;       // Set as INPUT
 229   1         gSMBNumBytesToWR = 2;
 230   1         SMB_Write();  // Initiate SMBus write
 231   1      }
 232          
 233          unsigned char read_i2c_port()
 234          {
 235   1         while(SMB_BUSY);
 236   1         gTarget = MCP23008_ADDR;
 237   1         gSMBDataOUT[0]  = MCP23008_GPIO;
 238   1         gSMBNumBytesToWR = 1;
 239   1         SMB_Write();  // Initiate SMBus write
 240   1         while(SMB_BUSY);
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 5   

 241   1         gTarget = MCP23008_ADDR;
 242   1         gSMBNumBytesToRD = 1;
 243   1         SMB_Read();  // Initiate SMBus write
 244   1         return gSMBDataIN[0];
 245   1      }
 246          
 247          void setMotorRA(unsigned char vitesse,bit direction)
 248          {
 249   1         unsigned int i=0;
 250   1         TR0=0;
 251   1         for(i=0;i<50000;i++);//voire figure 1
 252   1         DIR_RA=direction;
 253   1         for(i=0;i<50000;i++);//voire figure 1
 254   1         switch(vitesse)
 255   1         {
 256   2            case VITESSE_RA_SIDERAL://suivi sideral
 257   2               gVitesseRAH=VITESSE_RA_SIDERAL_HIGH;
 258   2               gVitesseRAL=VITESSE_RA_SIDERAL_LOW;
 259   2            break;
 260   2            case VITESSE_RA_LUNE://suivi Lune
 261   2               gVitesseRAH=VITESSE_RA_LUNE_HIGH;
 262   2               gVitesseRAL=VITESSE_RA_LUNE_LOW;
 263   2            break;
 264   2            case VITESSE_RA_PLANETE://suivi Soleil-Planete generale
 265   2               gVitesseRAH=VITESSE_RA_SOLEIL_HIGH;//
 266   2               gVitesseRAL=VITESSE_RA_SOLEIL_LOW;
 267   2            break;
 268   2            case VITESSE_RA_ISS://suivi ISS
 269   2               gVitesseRAH=VITESSE_RA_ISS_HIGH;
 270   2               gVitesseRAL=VITESSE_RA_ISS_LOW;
 271   2            break;
 272   2            case VITESSE_X05://x0,5
 273   2               gVitesseRAH=VITESSE_RA_X05_HIGH;
 274   2               gVitesseRAL=VITESSE_RA_X05_LOW;
 275   2            break;
 276   2            case VITESSE_X2://x2
 277   2               gVitesseRAH=VITESSE_RA_X2_HIGH;
 278   2               gVitesseRAL=VITESSE_RA_X2_LOW;
 279   2            break;
 280   2            case VITESSE_X8://x8
 281   2               gVitesseRAH=VITESSE_RA_X8_HIGH;
 282   2               gVitesseRAL=VITESSE_RA_X8_LOW;
 283   2            break;
 284   2            case VITESSE_X16://x16
 285   2               gVitesseRAH=VITESSE_RA_X16_HIGH;
 286   2               gVitesseRAL=VITESSE_RA_X16_LOW;
 287   2            break;
 288   2            case VITESSE_MAX://max
 289   2               gVitesseRAH=VITESSE_RA_MAX_HIGH;
 290   2               gVitesseRAL=VITESSE_RA_MAX_LOW;
 291   2            break;
 292   2            default://suivi sideral
 293   2               gVitesseRAH=VITESSE_RA_SIDERAL_HIGH;
 294   2               gVitesseRAL=VITESSE_RA_SIDERAL_LOW;      
 295   2            break;
 296   2         }
 297   1         TH0=gVitesseRAH ;//Charge la valeur dans le registre MSB du timer 0
 298   1         TL0=gVitesseRAL;//Charge la valeur dans le registre LSB du timer 0
 299   1         TR0=1;
 300   1      }
 301          
 302          void setMotorDEC(unsigned char vitesse,bit direction)
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 6   

 303          {
 304   1         unsigned int i=0;
 305   1         SFRPAGE   = CONFIG_PAGE;
 306   1         TMR4CN&=~0x04;
 307   1         SFRPAGE   = LEGACY_PAGE;
 308   1         for(i=0;i<50000;i++);//voire figure 1
 309   1         NSLEEP_DEC=1;//Attention il faut 1.7ms au chip pour se rallumer, peut creer des erreur de suivi
 310   1         DIR_DEC=direction;
 311   1         for(i=0;i<50000;i++);//voire figure 1
 312   1         switch(vitesse)
 313   1         {
 314   2            case VITESSE_X05://x0,5
 315   2               gVitesseDEC=VITESSE_DEC_X05;
 316   2               SFRPAGE   = CONFIG_PAGE;
 317   2               TMR4CN|=0x04;
 318   2               SFRPAGE   = LEGACY_PAGE;
 319   2            break;
 320   2            case VITESSE_X2://x2
 321   2               gVitesseDEC=VITESSE_DEC_X2;
 322   2               SFRPAGE   = CONFIG_PAGE;
 323   2               TMR4CN|=0x04;
 324   2               SFRPAGE   = LEGACY_PAGE;
 325   2            break;
 326   2            case VITESSE_X8://x8
 327   2               gVitesseDEC=VITESSE_DEC_X8;
 328   2               SFRPAGE   = CONFIG_PAGE;
 329   2               TMR4CN|=0x04;
 330   2               SFRPAGE   = LEGACY_PAGE;
 331   2            break;
 332   2            case VITESSE_X16://x16
 333   2               gVitesseDEC=VITESSE_DEC_X16;
 334   2               SFRPAGE   = CONFIG_PAGE;
 335   2               TMR4CN|=0x04;
 336   2               SFRPAGE   = LEGACY_PAGE;
 337   2            break;
 338   2            case VITESSE_MAX://max
 339   2               gVitesseDEC=VITESSE_DEC_MAX;
 340   2               SFRPAGE   = CONFIG_PAGE;
 341   2               TMR4CN|=0x04;
 342   2               SFRPAGE   = LEGACY_PAGE;
 343   2            break;
 344   2            default://suivi sideral
 345   2              stopMotorDec(); 
 346   2            break;
 347   2         }
 348   1      }
 349          
 350          void stopMotorDec()
 351          {
 352   1         SFRPAGE   = CONFIG_PAGE;
 353   1         TMR4CN&=~0x04;
 354   1         SFRPAGE   = LEGACY_PAGE;
 355   1         NSLEEP_DEC=0;
 356   1      }
 357          
 358          void decodeUartRaspberryPi()
 359          {
 360   1         if((gUart0Rx[0]=='R')&&(gUart0Rx[1]=='A'))
 361   1         {
 362   2            if((gUart0Rx[2]=='+'))
 363   2            {
 364   3               setMotorRA(gVitesseDeplacement,gDirRa);
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 7   

 365   3            }
 366   2            else if (gUart0Rx[2]=='-')
 367   2            {
 368   3               setMotorRA(gVitesseDeplacement,!gDirRa);
 369   3            }
 370   2            else//=='0'
 371   2            {
 372   3               setMotorRA(gAstrSuivi,gDirRa);
 373   3            }
 374   2         }
 375   1         else if((gUart0Rx[0]=='D')&&(gUart0Rx[1]=='E')&&(gUart0Rx[2]=='C'))
 376   1         {
 377   2            if((gUart0Rx[3]=='+'))
 378   2            {
 379   3               setMotorDEC(gVitesseDeplacement,gDirDec);
 380   3            }
 381   2            else if (gUart0Rx[3]=='-')
 382   2            {
 383   3               setMotorDEC(gVitesseDeplacement,!gDirDec);
 384   3            }
 385   2            else//=='0'
 386   2            {
 387   3               stopMotorDec();
 388   3            }
 389   2         }
 390   1         else if((gUart0Rx[0]=='C')&&(gUart0Rx[1]=='O')&&(gUart0Rx[2]=='N')&&(gUart0Rx[3]=='N')&&(gUart0Rx[4]=='
             -E')&&(gUart0Rx[5]=='C')&&(gUart0Rx[6]=='T'))//connect
 391   1         {
 392   2            stopMotorDec();
 393   2            setMotorRA(gAstrSuivi,gDirRa);
 394   2         }
 395   1         else if((gUart0Rx[0]=='D')&&(gUart0Rx[1]=='I')&&(gUart0Rx[2]=='S')&&(gUart0Rx[3]=='C')&&(gUart0Rx[4]=='
             -O')&&(gUart0Rx[5]=='N')&&(gUart0Rx[6]=='N')&&(gUart0Rx[7]=='E')&&(gUart0Rx[8]=='C')&&(gUart0Rx[9]=='T'))//connect
 396   1         {
 397   2            stopMotorDec();
 398   2            setMotorRA(gAstrSuivi,gDirRa);
 399   2         }
 400   1         else//Ne reconnait pas la commande, fais suivre au slave
 401   1         {
 402   2            //gUart1Tx[0]
 403   2            strcpy(gUart1Tx,gUart0Rx);
 404   2            SCON1|=0x02;
 405   2         }
 406   1      }
 407          
 408          
 409          
 410          /*---------------------------------------------------------------------------*-
 411          uart0()
 412          -----------------------------------------------------------------------------
 413          Descriptif: Fonction d'interruption de l'uart0 vecteur 4
 414          Entree    : --
 415          Sortie    : --
 416          -*---------------------------------------------------------------------------*/
 417          void uart0() interrupt 4
 418          {
 419   1         if(TI0)
 420   1         {
 421   2            TI0=0;
 422   2            if(gUart0Tx[gUart0NbrByteTx]!=0)
 423   2            {
 424   3               SBUF0=gUart0Tx[gUart0NbrByteTx];
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 8   

 425   3               gUart0NbrByteTx++;
 426   3            }
 427   2            else
 428   2            {
 429   3               gUart0NbrByteTx=0;
 430   3            }
 431   2         }
 432   1         
 433   1         if(RI0)
 434   1         {
 435   2            RI0=0;
 436   2            gUart0Rx[gUart0NbrByteRx]=SBUF0;
 437   2            if(gUart0Rx[gUart0NbrByteRx]=='#')
 438   2             {
 439   3                gUart0FlagReceive=1;
 440   3                gUart0Rx[gUart0NbrByteRx+1]=0;
 441   3                gUart0NbrByteRx=0;
 442   3             }
 443   2             else
 444   2             {
 445   3                gUart0NbrByteRx=(gUart0NbrByteRx+1)%20;
 446   3             }
 447   2         }
 448   1      }
 449          
 450          /*---------------------------------------------------------------------------*-
 451          uart1()
 452          -----------------------------------------------------------------------------
 453          Descriptif: Fonction d'interruption de l'uart1 vecteur 16
 454          Entree    : --
 455          Sortie    : --
 456          -*---------------------------------------------------------------------------*/
 457          void uart1() interrupt 16
 458          {
 459   1         if(SCON1&0x02)//TI1
 460   1         {
 461   2            SCON1=SCON1&~0x02;
 462   2            if(gUart1Tx[gUart1NbrByteTx]!=0)
 463   2            {
 464   3               SBUF1=gUart1Tx[gUart1NbrByteTx];
 465   3               gUart1NbrByteTx++;
 466   3            }
 467   2            else
 468   2            {
 469   3               gUart1NbrByteTx=0;
 470   3            }
 471   2         }
 472   1         
 473   1         if(SCON1&0x01)//RI1
 474   1         {
 475   2            SCON1=SCON1&~0x01;
 476   2            gUart1Rx[gUart1NbrByteRx]=SBUF1;
 477   2            if(gUart1Rx[gUart1NbrByteRx]=='\n')
 478   2             {
 479   3                gUart1FlagReceive=1;
 480   3                gUart1Rx[gUart1NbrByteRx+1]=0;
 481   3                gUart1NbrByteRx=0;
 482   3             }
 483   2             else
 484   2             {
 485   3                gUart1NbrByteRx=(gUart1NbrByteRx+1)%20;
 486   3             }
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 9   

 487   2         }
 488   1      }
 489          
 490          /*---------------------------------------------------------------------------*-
 491             UART_Init ()
 492            -----------------------------------------------------------------------------
 493             Descriptif: Configure l'UART par ces valeur par defaut
 494                         (il ne fait rien)
 495             Entrée    : --
 496             Sortie    : --
 497          -*---------------------------------------------------------------------------*/
 498          void UART_Init()
 499          {
 500   1          SCON0     = 0x10;
 501   1          //SBRLL1    = 0x3C;
 502   1          //SBRLH1    = 0xF6;
 503   1          //SCON1     = 0x10;
 504   1          //SBCON1    = 0x43;
 505   1         
 506   1         //57600 Uart1
 507   1          SBRLL1    = 0x5F;
 508   1          SBRLH1    = 0xFE;
 509   1          SCON1     = 0x10;
 510   1          SBCON1    = 0x43;
 511   1         
 512   1         //115200 Uart1
 513   1      // SBRLL1    = 0x30;
 514   1      //    SBRLH1    = 0xFF;
 515   1      //    SCON1     = 0x10;
 516   1      //    SBCON1    = 0x43;
 517   1      }
 518          
 519          /*---------------------------------------------------------------------------*-
 520          Init_int ()
 521          -----------------------------------------------------------------------------
 522          Descriptif:
 523          Interruption 0 : P0.6 - Descendant
 524          Interruption 1 : P0.7 - Descendant
 525          Entree    : --
 526          Sortie    : --
 527          -*---------------------------------------------------------------------------*/
 528          void Init_int()
 529          {
 530   1         EX0=0;//Autorise l'interruption externe 0
 531   1         EX1=0;//Autorise l'interruption externe 1
 532   1         IT0=1;//interruption 0 sur flanc
 533   1         IT1=1;//interruption 1 sur flanc
 534   1         IT01CF= IT01CF &~ 0xFF;//Clear le registre des interruption
 535   1                               // +-------- INT1 Polarite
 536   1                               // |+++----- Selection du canal P0.x de l'interruption 1
 537   1                               // ||||+---- INT0 Polarite
 538   1                               // |||||+++- Selection du canal P0.x de l'interruption 0
 539   1                               // ||||||||  (000: Select P0.0)
 540   1                               // ||||||||  ...
 541   1                               // ||||||||  ...
 542   1                               // ||||||||  (111: Select P0.7)  
 543   1         IT01CF= IT01CF | 0x76;// 01110110
 544   1      
 545   1         IE0=0; IE0=0; IE0=0;//clear du flag d'interruption 0 (3* pour eviter les bug)
 546   1         IE1=0; IE1=0; IE1=0;//clear du flag d'interruption 1 (3* pour eviter les bug)
 547   1         EX0=1;//Active l'interruption 0
 548   1         EX1=1;//Active l'interruption 1
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 10  

 549   1      }
 550          
 551          
 552          /*---------------------------------------------------------------------------*-
 553          interruption0()
 554          -----------------------------------------------------------------------------
 555          Descriptif: Fonction d'interruption INT0 vecteur 0
 556                      Pin :P0.6 - Descendant
 557          Entree    : --
 558          Sortie    : --
 559          -*---------------------------------------------------------------------------*/
 560          void interruption_ST4_RA() interrupt 0
 561          {
 562   1         IT01CF=IT01CF^0x08;
 563   1         if((!ST4_RA_POS)&&(!ST4_RA_NEG))
 564   1         {
 565   2            setMotorRA(gAstrSuivi,gDirRa);
 566   2            gFlagMovingRA=0;
 567   2         }
 568   1         else if((ST4_RA_POS)&&(ST4_RA_NEG))
 569   1         {
 570   2            setMotorRA(gAstrSuivi,gDirRa);
 571   2            gFlagMovingRA=0;
 572   2         }
 573   1         else if((ST4_RA_POS)&&(!ST4_RA_NEG))
 574   1         {
 575   2            setMotorRA(gVitesseDeplacement,!gDirRa);
 576   2            gFlagMovingRA=1;
 577   2         }
 578   1         else if((!ST4_RA_POS)&&(ST4_RA_NEG))
 579   1         {
 580   2            setMotorRA(gVitesseDeplacement,gDirRa);
 581   2            gFlagMovingRA=1;
 582   2         }
 583   1      }
 584          /*---------------------------------------------------------------------------*-
 585          interruption1()
 586          -----------------------------------------------------------------------------
 587          Descriptif: Fonction d'interruption 1 vecteur 2
 588                      Pin :P0.7 - Descendant
 589          Entree    : --
 590          Sortie    : --
 591          -*---------------------------------------------------------------------------*/
 592          void interruption_ST4_DEC() interrupt 2
 593          {
 594   1         IT01CF=IT01CF^0x80;
 595   1         if((!ST4_DEC_POS)&&(!ST4_DEC_NEG))//00
 596   1         {
 597   2            stopMotorDec();
 598   2         }
 599   1         else if((ST4_DEC_POS)&&(ST4_DEC_NEG))//11
 600   1         {
 601   2            stopMotorDec();
 602   2         }
 603   1         else if((ST4_DEC_POS)&&(!ST4_DEC_NEG))//10
 604   1         {
 605   2            setMotorDEC(gVitesseDeplacement,gDirDec);
 606   2         }
 607   1         else if((!ST4_DEC_POS)&&(ST4_DEC_NEG))//01
 608   1         {
 609   2            setMotorDEC(gVitesseDeplacement,!gDirDec);
 610   2         }
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 11  

 611   1      }
 612          
 613          /*---------------------------------------------------------------------------*-
 614          TimerInit ()
 615          -----------------------------------------------------------------------------
 616          Descriptif:
 617          Timer 0 : Mode 16bit - Prediv 48 - tempo 51,94milli
 618          Timer 1 : Mode 16bit - Prediv 48 - tempo 51,94milli
 619          Entree    : --
 620          Sortie    : --
 621          -*---------------------------------------------------------------------------*/
 622          void TimerInit()
 623          {
 624   1         //Timer 0 et 1
 625   1         TR0 = 0;//Stop le timer 0
 626   1         TR1 = 0;
 627   1         ET0 = 0;//Desactive l'interruption du timer 0
 628   1         ET1=0;
 629   1         TMOD &= ~0x0F;//Clear le registre du mode 0
 630   1                      // +-------- Timer 1 Gate Control
 631   1                      // |+------- Counter/Timer1 Select
 632   1                      // ||++----- choix du mode du timer 1
 633   1                      // ||||+---- Timer 0 Gate Control
 634   1                      // |||||+--- Counter/Timer0 Select
 635   1                      // ||||||++- choix du mode du timer 0
 636   1                      // ||||||||  (00 : Mode 0, 13-bit Counter/Timer)
 637   1                      // ||||||||  (01 : Mode 1, 16-bit Counter/Timer)
 638   1                      // ||||||||  (10 : Mode 2, 8-bit Counter/Timer with Auto-Reload)
 639   1                      // ||||||||  (11 : Mode 3, Two 8-bit Counter/Timers)  
 640   1         TMOD |= 0x21;// 00000001
 641   1         CKCON &= ~0x07;//clear les bit de selection pour les timer 0 et 1 et le prescalaire
 642   1                       // +-------- Timer 3 High Byte Clock Select.
 643   1                       // |+------- Timer 3 Low Byte Clock Select.
 644   1                       // ||+------ Timer 2 High Byte Clock Select
 645   1                       // |||+----- Timer 2 Low Byte Clock Select.
 646   1                       // ||||+---- Timer 1 Clock Select.
 647   1                       // |||||+--- Timer 0 Clock Select.
 648   1                       // ||||||++- Timer 0/1 Prescale Bits.
 649   1                       // ||||||||  (00: System clock divided by 12)
 650   1                       // ||||||||  (01: System clock divided by 4)
 651   1                       // ||||||||  (10: System clock divided by 48)
 652   1                       // ||||||||  (11: External clock divided by 8 (synchronized with the system clock))  
 653   1         CKCON |= 0x02;// 00000010
 654   1         TH0=gVitesseRAH;//Charge la valeur dans le registre MSB du timer 0
 655   1         TL0=gVitesseRAL;//Charge la valeur dans le registre LSB du timer 0
 656   1         TH1=TL1=BAUD_UART0;//Charge la valeur dans le registre LSB du timer 0
 657   1         TF0 = 0;//clear le flag d'interruption du timer 0
 658   1         TF1 = 0;
 659   1         ET0 = 1;//Autorise l'interruption du timer 0
 660   1         //ET1 = 1;
 661   1         
 662   1         //Init Timer 4 
 663   1         SFRPAGE   = CONFIG_PAGE;
 664   1         TMR4CN = 0x00;//Mode 16 bit auto reload
 665   1         TMR4RLH=0xF9;
 666   1         TMR4RLL=0x1F;
 667   1         SFRPAGE   = LEGACY_PAGE;
 668   1      }
 669          
 670          /*---------------------------------------------------------------------------*-
 671          timer0()
 672          -----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 12  

 673          Descriptif: Fonction d'interruption Timer0 vecteur 1
 674                    Temporisation de 51,94milli
 675                    Mode : 16bit
 676          Entree    : --
 677          Sortie    : --
 678          -*---------------------------------------------------------------------------*/
 679          void timer0() interrupt 1
 680          {
 681   1         TR0=0;
 682   1         TH0=gVitesseRAH ;//Charge la valeur dans le registre MSB du timer 0
 683   1         TL0=gVitesseRAL;//Charge la valeur dans le registre LSB du timer 0
 684   1         TR0=1;
 685   1         STEP_RA=!STEP_RA;
 686   1      }
 687          
 688          ///*---------------------------------------------------------------------------*-
 689          //timer1()
 690          //-----------------------------------------------------------------------------
 691          //Descriptif: Fonction d'interruption Timer1 vecteur 3
 692          //          Mode : 8 bit 9600baud
 693          //Entree    : --
 694          //Sortie    : --
 695          //-*---------------------------------------------------------------------------*/
 696          //void timer1() interrupt 3
 697          //{
 698          //   
 699          //}
 700          
 701          /*---------------------------------------------------------------------------*-
 702          timer4()
 703          -----------------------------------------------------------------------------
 704          Descriptif: Fonction d'interruption Timer4 vecteur 19
 705                    Mode : 16bit autoreload
 706          Entree    : --
 707          Sortie    : --
 708          -*---------------------------------------------------------------------------*/
 709          void timer4() interrupt 19
 710          {
 711   1         static unsigned int cpt=0;
 712   1         SFRPAGE   = CONFIG_PAGE;
 713   1         TMR4CN &=~0xC0;//Clear pending flag
 714   1         SFRPAGE   = LEGACY_PAGE;
 715   1         cpt++;
 716   1         if(cpt>=gVitesseDEC)
 717   1         {
 718   2            STEP_DEC=!STEP_DEC;
 719   2            cpt=0;
 720   2         }
 721   1      }
 722          
 723          /*---------------------------------------------------------------------------*-
 724             ClockInit ()
 725            -----------------------------------------------------------------------------
 726             Descriptif: Initialisation du mode de fonctionnement du clock système 
 727                   choix : SYSCLK : oscillateur HF interne à 48 MHz
 728          
 729             Entrée    : --
 730             Sortie    : --
 731          -*---------------------------------------------------------------------------*/
 732          void ClockInit()
 733          {  
 734   1         
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 13  

 735   1                           // +--------- clock interne LF
 736   1                           // | (1 : oscillateur LF : enable)
 737   1                           // | (0 : oscillateur LF: desable)
 738   1                           // |+-------- en lecture seule 1 : signal que oscillateur 
 739   1                           // ||         interne fonctionne à sa valeur de prog.
 740   1                           // ||++++---- réglage fin de la fréquence de l'osc. LF
 741   1                           // ||||||++-- choix du diviseur :
 742   1                           // ||||||||       (00 : Osc LF /8 -> f = 10 KHz)
 743   1                           // ||||||||       (01 : Osc LF /4 -> f = 20 KHz)
 744   1                           // ||||||||       (10 : Osc LF /2 -> f = 40 KHz)
 745   1                           // ||||||||       (11 : Osc LF /1 -> f = 80 KHz)
 746   1         OSCLCN |= 0x00;   // 00000000 
 747   1      
 748   1                           // +--------- non utilisé
 749   1                           // |+++------ Sélection du clock USB 
 750   1                           // ||||           (010 : Oscil ext. : limiter la conso.)
 751   1                           // ||||+----- clock out select
 752   1                           // |||||          (0 : sortie sysclk non synchronisée)
 753   1                           // |||||          (1 : sortie sysclk synchronisée)
 754   1                           // |||||+++-- choix du clock système
 755   1                           // ||||||||       (000 : Oscil interne 48/4  = 1.5, 3, 6 ou
 756   1                           // ||||||||              12 MHz selon le choix du diviseur 
 757   1                           // ||||||||              dans OSCICN
 758   1                           // ||||||||       (001 : Oscil externe  = x  MHz)
 759   1                           // ||||||||       (010 : Oscil interne 48/2 = 24 MHz)
 760   1                           // ||||||||       (011 : Oscil interne 48/1 = 48 MHz)    
 761   1                           // ||||||||       (100 : Oscil interne LF = 80 KHz max)   
 762   1                           // ||||||||       (101 à 111 : réservés)   
 763   1         CLKSEL = 0x03;    // 00000011  
 764   1      
 765   1                           // +--------- clock interne HF
 766   1                           // |              (1 : oscillateur LF : enable)
 767   1                           // |              (0 : oscillateur LF: desable)
 768   1                           // |+-------- en lecture seule 1 : signal que oscillateur 
 769   1                           // ||              interne fonctionne à sa valeur de prog.
 770   1                           // ||+------- 1 : suspend l'oscillateur interne
 771   1                           // |||+++---- non utilisés
 772   1                           // ||||||++-- choix du diviseur :
 773   1                           // ||||||||       (00 : 12/8 -> f =  1.5 MHz)
 774   1                           // ||||||||       (01 : 12/4 -> f =  3   MHz)
 775   1                           // ||||||||       (10 : 12/2 -> f =  6   MHz)
 776   1                           // ||||||||       (11 : 12/1 -> f = 12   MHz)
 777   1         OSCICN = 0xC3;    // 11000011 
 778   1         
 779   1         FLSCL = 0x90;     // A utiliser si le clock system est à 48 MHz
 780   1      
 781   1      } // ClockInit ----------------------------------------------------------------
 782          
 783          
 784          //-----------------------------------------------------------------------------
 785          // SMBus_Init
 786          //-----------------------------------------------------------------------------
 787          //
 788          // Return Value : None
 789          // Parameters   : None
 790          //
 791          // SMBus configured as follows:
 792          // - SMBus enabled
 793          // - Slave mode inhibited
 794          // - Timer2 used as clock source. The maximum SCL frequency will be
 795          //   approximately 1/3 the Timer1 overflow rate
 796          // - Setup and hold time extensions enabled
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 14  

 797          // - Bus Free and SCL Low timeout detection enabled
 798          //
 799          void SMBus_Init (void)
 800          {
 801   1         SMB0CF = 0x5E;                      // Use Timer2 overflows as SMBus clock
 802   1                                             // source;
 803   1                                             // Disable slave mode;
 804   1                                             // Enable setup & hold time
 805   1                                             // extensions;
 806   1                                             // Enable SMBus Free timeout detect;
 807   1                                             // Enable SCL low timeout detect;
 808   1      
 809   1         SMB0CF |= 0x80;                     // Enable SMBus;
 810   1      }
 811          
 812          
 813          //-----------------------------------------------------------------------------
 814          // Timer2_Init
 815          //-----------------------------------------------------------------------------
 816          //
 817          // Return Value : None
 818          // Parameters   : None
 819          //
 820          // Timer2 configured as the SMBus clock source as follows:
 821          // - Timer2 in 8-bit auto-reload mode
 822          // - SYSCLK or SYSCLK / 4 as Timer1 clock source
 823          // - Timer2 overflow rate => 3 * SMB_FREQUENCY
 824          // - The resulting SCL clock rate will be ~1/3 the Timer2 overflow rate
 825          // - Timer2 enabled
 826          //
 827          void Timer2_Init (void)
 828          {
 829   1         TMR2CN    |= 0x0C;//0x0C
 830   1         TMR2RLH   |= 0xD4;//0x7B
 831   1      }
 832          
 833          //-----------------------------------------------------------------------------
 834          // Timer3_Init
 835          //-----------------------------------------------------------------------------
 836          //
 837          // Return Value : None
 838          // Parameters   : None
 839          //
 840          // Timer3 configured for use by the SMBus low timeout detect feature as
 841          // follows:
 842          // - Timer3 in 16-bit auto-reload mode
 843          // - SYSCLK/12 as Timer3 clock source
 844          // - Timer3 reload registers loaded for a 25ms overflow period
 845          // - Timer3 pre-loaded to overflow after 25ms
 846          // - Timer3 enabled
 847          //
 848          void Timer3_Init (void)
 849          {
 850   1         TMR3CN = 0x00;                      // Timer3 configured for 16-bit auto-
 851   1                                             // reload, low-byte interrupt disabled
 852   1      
 853   1         CKCON &= ~0x40;                     // Timer3 uses SYSCLK/12
 854   1      
 855   1         TMR3RL = -(SYSCLK/12/40);           // Timer3 configured to overflow after
 856   1         TMR3 = TMR3RL;                      // ~25ms (for SMBus low timeout detect):
 857   1                                             // 1/.025 = 40
 858   1      
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 15  

 859   1         EIE1 |= 0x80;                       // Timer3 interrupt enable
 860   1         TMR3CN |= 0x04;                     // Start Timer3
 861   1      }
 862          
 863          //-----------------------------------------------------------------------------
 864          // SMBus Interrupt Service Routine (ISR)
 865          //-----------------------------------------------------------------------------
 866          //
 867          // SMBus ISR state machine
 868          // - Master only implementation - no slave or arbitration states defined
 869          // - All incoming data is written to global variable array <gSMBDataIN>
 870          // - All outgoing data is read from global variable array <gSMBDataOUT>
 871          //
 872          void SMBus_ISR (void) interrupt 7
 873          {
 874   1         bit FAIL = 0;                       // Used by the ISR to flag failed
 875   1                                             // transfers
 876   1      
 877   1         static unsigned char sent_byte_counter;
 878   1         static unsigned char rec_byte_counter;
 879   1      
 880   1         if (ARBLOST0 == 0)                   // Check for errors
 881   1         {
 882   2            // Normal operation
 883   2            switch (SMB0CN & 0xF0)           // Status vector
 884   2            {
 885   3               // Master Transmitter/Receiver: START condition transmitted.
 886   3               case SMB_MTSTA:
 887   3                  SMB0DAT = gTarget;          // Load address of the gTarget slave
 888   3                  SMB0DAT &= 0xFE;           // Clear the LSB of the address for the
 889   3                                             // R/W bit
 890   3                  SMB0DAT |= SMB_RW;         // Load R/W bit
 891   3                  STA0 = 0;                   // Manually clear START bit
 892   3                  rec_byte_counter = 1;      // Reset the counter
 893   3                  sent_byte_counter = 1;     // Reset the counter
 894   3                  break;
 895   3      
 896   3               // Master Transmitter: Data byte transmitted
 897   3               case SMB_MTDB:
 898   3                  if (ACK0)                   // Slave ACK0?
 899   3                  {
 900   4                     if (SMB_RW == WRITE)    // If this transfer is a WRITE,
 901   4                     {
 902   5                        if (sent_byte_counter <= gSMBNumBytesToWR)
 903   5                        {
 904   6                           // send data byte
 905   6                           SMB0DAT = gSMBDataOUT[sent_byte_counter-1];
 906   6                           sent_byte_counter++;
 907   6                        }
 908   5                        else
 909   5                        {
 910   6                           STO0 = 1;          // Set STO0 to terminate transfer
 911   6                           SMB_BUSY = 0;     // And free SMBus interface
 912   6                        }
 913   5                     }
 914   4                     else {}                 // If this transfer is a READ,
 915   4                                             // proceed with transfer without
 916   4                                             // writing to SMB0DAT (switch
 917   4                                             // to receive mode)
 918   4      
 919   4      
 920   4                  }
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 16  

 921   3                  else                       // If slave NACK,
 922   3                  {
 923   4                     STO0 = 1;                // Send STOP condition, followed
 924   4                     STA0 = 1;                // By a START
 925   4                     NUM_ERRORS++;           // Indicate error
 926   4                  }
 927   3                  break;
 928   3      
 929   3               // Master Receiver: byte received
 930   3               case SMB_MRDB:
 931   3                  if (rec_byte_counter < gSMBNumBytesToRD)
 932   3                  {
 933   4                     gSMBDataIN[rec_byte_counter-1] = SMB0DAT; // Store received
 934   4                                                                // byte
 935   4                     ACK0 = 1;                // Send ACK0 to indicate byte received
 936   4                     rec_byte_counter++;     // Increment the byte counter
 937   4                  }
 938   3                  else
 939   3                  {
 940   4                     gSMBDataIN[rec_byte_counter-1] = SMB0DAT; // Store received
 941   4                                                                // byte
 942   4                     SMB_BUSY = 0;           // Free SMBus interface
 943   4                     ACK0 = 0;                // Send NACK to indicate last byte
 944   4                                             // of this transfer
 945   4      
 946   4                     STO0 = 1;                // Send STOP to terminate transfer
 947   4                  }
 948   3                  break;
 949   3      
 950   3               default:
 951   3                  FAIL = 1;                  // Indicate failed transfer
 952   3                                             // and handle at end of ISR
 953   3                  break;
 954   3      
 955   3            } // end switch
 956   2         }
 957   1         else
 958   1         {
 959   2            // ARBLOST = 1, error occurred... abort transmission
 960   2            FAIL = 1;
 961   2         } // end ARBLOST if
 962   1      
 963   1         if (FAIL)                           // If the transfer failed,
 964   1         {
 965   2            SMB0CF &= ~0x80;                 // Reset communication
 966   2            SMB0CF |= 0x80;
 967   2            STA0 = 0;
 968   2            STO0 = 0;
 969   2            ACK0 = 0;
 970   2      
 971   2            SMB_BUSY = 0;                    // Free SMBus
 972   2      
 973   2            FAIL = 0;
 974   2            //LED = 0;
 975   2      
 976   2            NUM_ERRORS++;                    // Indicate an error occurred
 977   2         }
 978   1      
 979   1         SI0 = 0;                             // Clear interrupt flag
 980   1      }
 981          
 982          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 17  

 983          // Timer3 Interrupt Service Routine (ISR)
 984          //-----------------------------------------------------------------------------
 985          //
 986          // A Timer3 interrupt indicates an SMBus SCL low timeout.
 987          // The SMBus is disabled and re-enabled here
 988          //
 989          void Timer3_ISR (void) interrupt 14
 990          {
 991   1         SMB0CF &= ~0x80;                    // Disable SMBus
 992   1         SMB0CF |= 0x80;                     // Re-enable SMBus
 993   1         TMR3CN &= ~0x80;                    // Clear Timer3 interrupt-pending
 994   1                                             // flag
 995   1         STA0 = 0;
 996   1         SMB_BUSY = 0;                       // Free SMBus
 997   1      }
 998          
 999          //-----------------------------------------------------------------------------
1000          // Support Functions
1001          //-----------------------------------------------------------------------------
1002          
1003          //-----------------------------------------------------------------------------
1004          // SMB_Write
1005          //-----------------------------------------------------------------------------
1006          //
1007          // Return Value : None
1008          // Parameters   : None
1009          //
1010          // Writes a single byte to the slave with address specified by the <gTarget>
1011          // variable.
1012          // Calling sequence:
1013          // 1) Write gTarget slave address to the <gTarget> variable
1014          // 2) Write outgoing data to the <gSMBDataOUT> variable array
1015          // 3) Call SMB_Write()
1016          //
1017          void SMB_Write (void)
1018          {
1019   1         while (SMB_BUSY);                   // Wait for SMBus to be free.
1020   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
1021   1         SMB_RW = 0;                         // Mark this transfer as a WRITE
1022   1         STA0 = 1;                            // Start transfer
1023   1      }
1024          
1025          //-----------------------------------------------------------------------------
1026          // SMB_Read
1027          //-----------------------------------------------------------------------------
1028          //
1029          // Return Value : None
1030          // Parameters   : None
1031          //
1032          // Reads a single byte from the slave with address specified by the <gTarget>
1033          // variable.
1034          // Calling sequence:
1035          // 1) Write gTarget slave address to the <gTarget> variable
1036          // 2) Call SMB_Write()
1037          // 3) Read input data from <gSMBDataIN> variable array
1038          //
1039          void SMB_Read (void)
1040          {
1041   1         while (SMB_BUSY);                   // Wait for bus to be free.
1042   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
1043   1         SMB_RW = 1;                         // Mark this transfer as a READ
1044   1      
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 18  

1045   1         STA0 = 1;                            // Start transfer
1046   1      
1047   1         while (SMB_BUSY);                   // Wait for transfer to complete
1048   1      }
1049          
1050          
1051          /*---------------------------------------------------------------------------*-
1052             PortInit ()
1053            -----------------------------------------------------------------------------
1054             Descriptif: autorise le fonctionnement du crossbar et de l'uart0
1055             Entrée    : --
1056             Sortie    : --
1057          -*---------------------------------------------------------------------------*/
1058          void PortInit () 
1059          {
1060   1         // P0.0  -  SDA (SMBus0), Open-Drain, Digital
1061   1          // P0.1  -  SCL (SMBus0), Push-Pull,  Digital
1062   1          // P0.2  -  TX1 (UART1), Push-Pull,  Digital
1063   1          // P0.3  -  RX1 (UART1), Open-Drain, Digital
1064   1          // P0.4  -  TX0 (UART0), Push-Pull,  Digital
1065   1          // P0.5  -  RX0 (UART0), Open-Drain, Digital
1066   1          // P0.6  -  Unassigned,  Open-Drain, Digital
1067   1          // P0.7  -  Unassigned,  Open-Drain, Digital
1068   1      
1069   1          // P1.0  -  Skipped,     Push-Pull,  Digital
1070   1          // P1.1  -  Skipped,     Push-Pull,  Digital
1071   1          // P1.2  -  Skipped,     Push-Pull,  Digital
1072   1          // P1.3  -  Skipped,     Open-Drain, Digital
1073   1          // P1.4  -  Skipped,     Push-Pull,  Digital
1074   1          // P1.5  -  Skipped,     Push-Pull,  Digital
1075   1          // P1.6  -  Skipped,     Push-Pull,  Digital
1076   1          // P1.7  -  Skipped,     Open-Drain, Digital
1077   1      
1078   1          // P2.0  -  Skipped,     Open-Drain, Digital
1079   1          // P2.1  -  Skipped,     Open-Drain, Digital
1080   1          // P2.2  -  Skipped,     Open-Drain, Digital
1081   1          // P2.3  -  Skipped,     Open-Drain, Digital
1082   1          // P2.4  -  Unassigned,  Open-Drain, Digital
1083   1          // P2.5  -  Unassigned,  Open-Drain, Digital
1084   1          // P2.6  -  Unassigned,  Open-Drain, Digital
1085   1          // P2.7  -  Unassigned,  Open-Drain, Digital
1086   1      
1087   1          // P3.0  -  Unassigned,  Open-Drain, Digital
1088   1      
1089   1          P0MDOUT   = 0x16;
1090   1          P1MDOUT   = 0xDD;//0xFF = schema
1091   1          P1SKIP    = 0xFF;
1092   1          P2SKIP    = 0x0F;
1093   1          XBR0      |= 0x05;
1094   1          XBR1      |= 0x40;
1095   1          XBR2      |= 0x01;
1096   1      
1097   1      } // PortInit ----------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2343    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     40    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     41    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   MASTER_TELESCOPE                                                  06/01/2019 14:58:03 PAGE 19  

   BIT SIZE         =     11    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
